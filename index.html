<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vivaria v4.5.2 - Flora Icons</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --pixel-font: 'Press Start 2P', cursive;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --ui-border: #4a69bd;
            --highlight: #f1c40f;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #87CEEB;
            color: white;
            font-family: var(--pixel-font);
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .hud-panel {
            background: var(--ui-bg); padding: 15px;
            border-radius: 4px; border: 3px solid var(--ui-border);
            pointer-events: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.6);
        }

        #inventory-bar { 
            display: flex; gap: 6px; margin-top: 10px; flex-wrap: wrap; 
            max-width: 600px; max-height: 100px; overflow-y: auto;
        }
        .inv-slot {
            width: 36px; height: 36px; background-color: rgba(0,0,0,0.5);
            border: 2px solid #555; position: relative; cursor: pointer; transition: transform 0.1s;
        }
        .inv-slot:hover { transform: scale(1.1); border-color: white; }
        .inv-slot span {
            position: absolute; bottom: 2px; right: 2px;
            font-size: 8px; color: white; text-shadow: 1px 1px 0 #000;
        }
        .selected { border-color: var(--highlight); box-shadow: 0 0 8px var(--highlight); }

        /* --- ICONS --- */
        .icon-1 { background: #5d4037; } 
        .icon-2 { background: linear-gradient(#4caf50, #5d4037); } 
        .icon-8 { background: #2e7d32; } 
        .icon-11 { background: linear-gradient(#ffffff, #5d4037); }

        .icon-3 { /* Stone */
            background-color: #78909c;
            background-image: linear-gradient(335deg, rgba(0,0,0,0.3) 23px, transparent 23px),
            linear-gradient(155deg, rgba(0,0,0,0.3) 23px, transparent 23px);
            background-size: 18px 18px;
        }
        .icon-4 { /* Sand */
            background-color: #fdd835;
            background-image: radial-gradient(#fbc02d 15%, transparent 16%);
            background-size: 8px 8px;
        }
        .icon-5 { /* Water */
            background-color: #29b6f6;
            background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255,255,255,0.3) 5px, rgba(255,255,255,0.3) 10px);
        }
        .icon-6 { /* Mud */
            background-color: #4a332a;
            background-image: linear-gradient(rgba(0,0,0,0.1) 2px, transparent 2px), linear-gradient(90deg, rgba(0,0,0,0.1) 2px, transparent 2px);
            background-size: 16px 16px;
        }
        .icon-7 { /* Wood */
            background-color: #5d4037;
            background-image: repeating-linear-gradient(90deg, transparent, transparent 4px, #3e2723 4px, #3e2723 8px);
        }
        .icon-12 { /* Planks */
            background-color: #a1887f;
            background-image: repeating-linear-gradient(0deg, transparent, transparent 8px, #5d4037 8px, #5d4037 10px);
            border: 2px solid #5d4037;
        }
        
        /* Ores */
        .ore-base { background-color: #546e7a; position: relative; }
        .icon-9 { background: radial-gradient(circle, #000 30%, #78909c 35%); } 
        .icon-10 { background: radial-gradient(circle, #ffd700 30%, #78909c 35%); } 
        .icon-13 { background: radial-gradient(circle, #00e5ff 30%, #78909c 35%); } 

        /* --- UNIQUE FLOWER ICONS --- */
        /* Forest */
        .icon-20 { background: radial-gradient(circle, #e91e63 40%, #2e7d32 50%); } /* Red */
        .icon-21 { background: radial-gradient(circle, #9c27b0 40%, #2e7d32 50%); } /* Purple */
        .icon-22 { background: radial-gradient(circle, #ffeb3b 40%, #2e7d32 50%); } /* Yellow */
        .icon-23 { background: radial-gradient(circle, #2196f3 40%, #2e7d32 50%); } /* Blue */
        .icon-24 { background: radial-gradient(circle, #f44336 40%, #2e7d32 50%); } /* Orange */
        /* Desert */
        .icon-25 { background: linear-gradient(to top, #558b2f, #8bc34a); border-radius: 4px; } /* Cactus */
        .icon-26 { background: linear-gradient(to top, #33691e, #558b2f); border-radius: 4px; }
        .icon-27 { background: linear-gradient(to top, #558b2f, #fdd835); border-radius: 4px; }
        .icon-28 { background: repeating-linear-gradient(45deg, #795548, #795548 2px, transparent 2px, transparent 4px); } /* Dead bush */
        .icon-29 { background: radial-gradient(circle, #795548 30%, transparent 35%); }
        /* Snow */
        .icon-30 { background: radial-gradient(circle, #81d4fa 40%, white 50%); }
        .icon-31 { background: radial-gradient(circle, #4fc3f7 40%, white 50%); }
        .icon-32 { background: linear-gradient(to top, #81d4fa, white); border-radius: 50%; }
        .icon-33 { background: #b3e5fc; border: 2px solid white; }
        .icon-34 { background: radial-gradient(circle, white 20%, #81d4fa 80%); }


        #modal-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 20;
        }
        .modal-box { background: var(--ui-bg); border: 4px solid var(--highlight); padding: 30px; text-align: center; }
        .size-btn {
            display: block; width: 100%; margin: 10px 0; padding: 15px;
            font-family: var(--pixel-font); background: #34495e; color: white;
            border: 2px solid #fff; cursor: pointer;
        }
        .size-btn:hover { background: var(--highlight); color: black; }

        .btn-group { display:flex; gap: 5px; margin-top: 5px;}
        button {
            font-family: var(--pixel-font); background: #34495e; border: 2px solid #bdc3c7;
            color: white; padding: 10px 15px; font-size: 10px; cursor: pointer;
        }
        button:hover { background: #2c3e50; border-color: var(--highlight); }

        .craft-btn { background: #d35400; border-color: #e67e22; width: 100%; margin-top:5px; }
        .craft-btn:hover { background: #e67e22; }

        #file-input { display: none; }

        canvas { display: block; cursor: crosshair; }
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-thumb { background: #f1c40f; }
    </style>
</head>
<body>

    <div id="modal-overlay">
        <div class="modal-box">
            <h2 style="color: #f1c40f; margin-bottom: 20px;">NEW WORLD GENERATION</h2>
            <button class="size-btn" onclick="confirmNewWorld(150, 60)">STANDARD (150x60)</button>
            <button class="size-btn" onclick="confirmNewWorld(300, 100)">LARGE (300x100)</button>
            <button class="size-btn" onclick="confirmNewWorld(600, 150)">MASSIVE (600x150)</button>
            <button class="size-btn" style="background:#c0392b" onclick="closeModal()">CANCEL</button>
        </div>
    </div>

    <div id="ui-layer">
        <div class="top-bar" style="display:flex; justify-content:space-between;">
            <div class="hud-panel">
                <h1 style="font-size: 16px; margin:0 0 10px 0; color: #f1c40f;">VIVARIA v4.5.2</h1>
                <div id="tool-display" style="color: #ff7675; font-size: 12px; margin-bottom:5px;">‚õèÔ∏è MINING</div>
                <div id="inventory-bar"></div>
            </div>
            <div class="hud-panel" style="text-align: right;">
                <div style="font-size: 10px; color: #bdc3c7; line-height: 1.6;">
                    [Arrows] Move<br>[Space] Jump<br>[E] Mode<br>[C] Craft Planks
                </div>
                <button class="craft-btn" onclick="craftPlanks()">Craft Planks</button>
            </div>
        </div>
        <div style="align-self: flex-end; pointer-events: auto; display: flex; flex-direction: column; align-items: flex-end;">
            <div class="btn-group">
                <button onclick="saveGame()">Save Browser</button>
                <button onclick="loadGame()">Load Browser</button>
                <button onclick="openModal()">New World</button>
            </div>
            <div class="btn-group">
                <button onclick="exportSave()" style="border-color: #27ae60;">Export File</button>
                <button onclick="document.getElementById('file-input').click()" style="border-color: #2980b9;">Import File</button>
                <input type="file" id="file-input" accept=".json" onchange="importSave(this)">
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let COLS = 150; 
        let ROWS = 60; 
        const TILE_SIZE = 32;

        const GRAVITY = 0.5;
        const WATER_GRAVITY = 0.1;
        const WATER_DRAG = 0.92; 
        const SWIM_FORCE = 1.5; 
        const BUOYANCY = -0.15; 
        
        const TILES = { 
            AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, SAND: 4, WATER: 5, MUD: 6,
            WOOD: 7, LEAVES: 8, COAL_ORE: 9, GOLD_ORE: 10, SNOW: 11, PLANKS: 12, DIAMOND_ORE: 13
        };

        const BASE_COLORS = {
            1: [28, 45, 30], // Dirt
            2: [100, 60, 35], // Grass
            3: [210, 10, 50], // Stone
            4: [45, 90, 60], // Sand
            6: [25, 35, 25], // Mud
            7: [30, 55, 30], // Wood
            8: [120, 50, 35], // Leaves
            9: [0, 0, 20], // Coal
            10: [50, 100, 50], // Gold
            11: [200, 30, 90], // Snow
            12: [35, 50, 50], // Planks
            13: [180, 80, 60] // Diamond
        };
        
        let world = [];
        let player = { x: 0, y: 0, width: 20, height: 44, vx: 0, vy: 0, grounded: false, facingRight: true, inWater: false };
        let camera = { x: 0, y: 0 };
        let mouseTile = { c: -1, r: -1 };
        let inventory = {}; 
        Object.values(TILES).forEach(v => { if(v !== 0) inventory[v] = 0; });
        for(let i=20; i<=34; i++) inventory[i] = 0; 
        
        let selectedBlock = TILES.DIRT;
        let mode = 'MINE'; 
        let tickCount = 0;
        let worldSeed = Math.random() * 10000;

        function pseudoRandom(x, y) {
            return Math.sin(x * 12.9898 + y * 78.233) * 43758.5453 - Math.floor(Math.sin(x * 12.9898 + y * 78.233) * 43758.5453);
        }

        function isPermeable(tile) {
            return tile === TILES.WOOD || tile === TILES.LEAVES || (tile >= 20 && tile <= 34);
        }

        function isSolid(tile) {
            if (tile === TILES.AIR) return false;
            if (tile === TILES.WATER) return false;
            if (isPermeable(tile)) return false;
            return true;
        }

        // --- WORLD GENERATION ---
        function initWorld(w, h) {
            COLS = w; ROWS = h;
            world = [];
            worldSeed = Math.random() * 10000; 
            let surfaceLevel = Math.floor(ROWS * 0.35);
            let heights = new Array(COLS).fill(0);

            for (let r = 0; r < ROWS; r++) {
                let row = [];
                for (let c = 0; c < COLS; c++) {
                    let cx = c + worldSeed; 
                    let heightNoise = Math.sin(cx * 0.04) * 5 + Math.sin(cx * 0.1) * 2;
                    let actualSurface = Math.floor(surfaceLevel + heightNoise);
                    if (r === 0) heights[c] = actualSurface;

                    let biomeNoise = Math.sin(cx * 0.015) + (Math.sin(cx * 0.05) * 0.1); 
                    let surfaceBlock, subBlock;

                    if (biomeNoise > 0.4 && biomeNoise < 0.6) {
                        if (Math.random() > 0.5) { surfaceBlock = TILES.SAND; subBlock = TILES.SAND; }
                        else { surfaceBlock = TILES.GRASS; subBlock = TILES.DIRT; }
                    } else if (biomeNoise < -0.4 && biomeNoise > -0.6) {
                        if (Math.random() > 0.5) { surfaceBlock = TILES.SNOW; subBlock = TILES.DIRT; }
                        else { surfaceBlock = TILES.GRASS; subBlock = TILES.DIRT; }
                    } else if (biomeNoise > 0.5) {
                        surfaceBlock = TILES.SAND; subBlock = TILES.SAND;
                    } else if (biomeNoise < -0.5) {
                        surfaceBlock = TILES.SNOW; subBlock = TILES.DIRT;
                    } else {
                        surfaceBlock = TILES.GRASS; subBlock = TILES.DIRT;
                    }

                    if (r < actualSurface) {
                        row.push(TILES.AIR);
                    } else if (r === actualSurface) {
                        row.push(surfaceBlock);
                    } else if (r > actualSurface && r < actualSurface + 15) {
                        row.push(subBlock);
                    } else {
                        let rand = Math.random();
                        if (rand < 0.015) row.push(TILES.COAL_ORE);
                        else if (rand < 0.018 && r > actualSurface + 25) row.push(TILES.GOLD_ORE);
                        else if (rand < 0.019 && r > ROWS - 15) row.push(TILES.DIAMOND_ORE); 
                        else row.push(TILES.STONE);
                    }
                }
                world.push(row);
            }

            for(let i=0; i < COLS/40; i++) {
                let lakeX = Math.floor(Math.random() * (COLS - 20)) + 10;
                carveLake(lakeX, heights[lakeX]);
            }

            for(let c=2; c < COLS-2; c++) {
                let r = heights[c];
                let ground = world[r][c];
                let plantY = r - 1;

                if (ground === TILES.GRASS && Math.random() < 0.12) {
                    growTree(plantY, c);
                    c += 2;
                } else if (world[plantY][c] === TILES.AIR) {
                    if (Math.random() < 0.3) {
                        let flowerId = 0;
                        if (ground === TILES.GRASS) flowerId = 20 + Math.floor(Math.random() * 5);
                        else if (ground === TILES.SAND) flowerId = 25 + Math.floor(Math.random() * 5);
                        else if (ground === TILES.SNOW) flowerId = 30 + Math.floor(Math.random() * 5);
                        if (flowerId > 0) world[plantY][c] = flowerId;
                    }
                }
            }
            
            cleanupFloatingBlocks();
            player.x = (COLS * TILE_SIZE) / 2;
            player.y = 0; player.vx = 0; player.vy = 0;
            updateHUD();
        }

        function growTree(baseR, baseC) {
            let height = 4 + Math.floor(Math.random() * 3);
            for(let h=0; h < height; h++) {
                if(baseR-h >= 0) world[baseR-h][baseC] = TILES.WOOD;
            }
            let crownY = baseR - height + 1;
            for(let y = crownY - 2; y <= crownY + 1; y++) {
                for(let x = baseC - 2; x <= baseC + 2; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        if (Math.abs(x - baseC) + Math.abs(y - crownY) <= 3) {
                             if(world[y][x] === TILES.AIR) world[y][x] = TILES.LEAVES;
                        }
                    }
                }
            }
        }

        function carveLake(cx, cy) {
            let r = 3 + Math.floor(Math.random() * 5); 
            for(let y = cy - r; y <= cy + r; y++) {
                for(let x = cx - r; x <= cx + r; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        let dist = Math.sqrt((x-cx)**2 + ((y-cy)*1.5)**2);
                        if (dist < r) {
                            if (y > cy) world[y][x] = TILES.WATER;
                            else world[y][x] = TILES.AIR;
                            if (dist > r - 1.5 && world[y][x] !== TILES.AIR && world[y][x] !== TILES.WATER) {
                                world[y][x] = TILES.MUD;
                            }
                        }
                    }
                }
            }
        }

        function cleanupFloatingBlocks() {
            for(let i=0; i<2; i++) {
                for (let c = 0; c < COLS; c++) {
                    for (let r = ROWS - 2; r >= 0; r--) {
                        let tile = world[r][c];
                        let isTerrain = (tile === TILES.DIRT || tile === TILES.GRASS || tile === TILES.STONE || tile === TILES.MUD || tile === TILES.SAND || tile === TILES.SNOW);
                        if (isTerrain && world[r+1][c] === TILES.AIR) world[r][c] = TILES.AIR;
                    }
                }
            }
        }

        // --- CELLULAR AUTOMATA ---
        function updateCellularAutomata() {
            let startC = tickCount % 2 === 0 ? 0 : COLS - 1;
            let endC = tickCount % 2 === 0 ? COLS : -1;
            let step = tickCount % 2 === 0 ? 1 : -1;

            for (let r = ROWS - 2; r >= 0; r--) {
                for (let c = startC; c !== endC; c += step) {
                    let tile = world[r][c];

                    // MUD DRYING
                    if (tile === TILES.MUD) {
                        let touchesWater = false;
                        if (r>0 && world[r-1][c] === TILES.WATER) touchesWater = true;
                        else if (r<ROWS-1 && world[r+1][c] === TILES.WATER) touchesWater = true;
                        else if (c>0 && world[r][c-1] === TILES.WATER) touchesWater = true;
                        else if (c<COLS-1 && world[r][c+1] === TILES.WATER) touchesWater = true;

                        if (!touchesWater && Math.random() < 0.007) world[r][c] = TILES.DIRT;
                    }

                    // GRASS REGROWTH
                    if (tile === TILES.DIRT) {
                        if (r>0 && world[r-1][c] === TILES.AIR) {
                            if (Math.random() < 0.003) { 
                                let cx = c + worldSeed;
                                let biomeNoise = Math.sin(cx * 0.015) + (Math.sin(cx * 0.05) * 0.1);
                                if (biomeNoise < -0.5) world[r][c] = TILES.SNOW;
                                else if (biomeNoise > 0.5) { }
                                else world[r][c] = TILES.GRASS;
                            }
                        }
                    }

                    // FLOWERS BREAK (No Inventory)
                    if (tile >= 20 && tile <= 34) { 
                        let below = world[r+1][c];
                        if (below === TILES.AIR || below === TILES.WATER) {
                            world[r][c] = TILES.AIR; 
                        }
                        continue;
                    }

                    // SAND
                    if (tile === TILES.SAND) {
                        if (world[r+1][c] === TILES.AIR || world[r+1][c] === TILES.WATER) {
                            world[r][c] = world[r+1][c]; world[r+1][c] = TILES.SAND;
                        } else if (world[r+1][c-1] === TILES.AIR && world[r][c-1] === TILES.AIR) {
                             world[r][c] = TILES.AIR; world[r+1][c-1] = TILES.SAND;
                        } else if (world[r+1][c+1] === TILES.AIR && world[r][c+1] === TILES.AIR) {
                             world[r][c] = TILES.AIR; world[r+1][c+1] = TILES.SAND;
                        }
                    }
                    
                    // WATER
                    if (tile === TILES.WATER) {
                        if (r + 1 < ROWS) {
                            let below = world[r+1][c];
                            if ((below === TILES.DIRT || below === TILES.GRASS) && Math.random() < 0.005) {
                                world[r+1][c] = TILES.MUD; 
                            }
                        }

                        let down = world[r+1][c];
                        if (down === TILES.AIR) {
                            world[r][c] = TILES.AIR; world[r+1][c] = TILES.WATER; continue;
                        } else if (down >= 20 && down <= 34) {
                            // WASH FLOWER (No Inventory)
                            world[r][c] = TILES.AIR; world[r+1][c] = TILES.WATER; continue;
                        } else if (isPermeable(down)) {
                            if (r+2 < ROWS && world[r+2][c] === TILES.AIR) {
                                world[r][c] = TILES.AIR; world[r+2][c] = TILES.WATER; continue;
                            }
                        }

                        let left = (c > 0) ? world[r][c-1] : -1;
                        let right = (c < COLS-1) ? world[r][c+1] : -1;
                        
                        let canLeft = (left === TILES.AIR || (left >= 20 && left <= 34));
                        let canRight = (right === TILES.AIR || (right >= 20 && right <= 34));
                        
                        if (!canLeft && isPermeable(left) && c > 1 && world[r][c-2] === TILES.AIR) canLeft = true; 
                        if (!canRight && isPermeable(right) && c < COLS-2 && world[r][c+2] === TILES.AIR) canRight = true;

                        if (canLeft && canRight) {
                            if (Math.random() > 0.5) tryMoveWater(r, c, r, c+1); else tryMoveWater(r, c, r, c-1);
                        } else if (canLeft) {
                            tryMoveWater(r, c, r, c-1);
                        } else if (canRight) {
                            tryMoveWater(r, c, r, c+1);
                        }
                    }
                }
            }
        }

        function tryMoveWater(r, c, targetR, targetC) {
            let target = world[targetR][targetC];
            if (target === TILES.AIR) {
                world[r][c] = TILES.AIR; world[targetR][targetC] = TILES.WATER;
            } 
            else if (target >= 20 && target <= 34) { 
                // WASH FLOWER (No Inventory)
                world[r][c] = TILES.AIR; world[targetR][targetC] = TILES.WATER;
            }
            else if (isPermeable(target)) {
                let dirC = targetC - c;
                let nextC = targetC + dirC;
                if (nextC >= 0 && nextC < COLS && world[targetR][nextC] === TILES.AIR) {
                    world[r][c] = TILES.AIR; world[targetR][nextC] = TILES.WATER;
                }
            }
        }

        // --- PHYSICS & CRAFTING ---
        function getTileAt(x, y) {
            let c = Math.floor(x / TILE_SIZE);
            let r = Math.floor(y / TILE_SIZE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return TILES.AIR;
            return world[r][c];
        }

        function craftPlanks() {
            if (inventory[TILES.WOOD] > 0) {
                let woodAmount = inventory[TILES.WOOD];
                inventory[TILES.WOOD] = 0;
                inventory[TILES.PLANKS] += woodAmount * 4;
                updateHUD();
                alert(`Crafted ${woodAmount * 4} Planks!`);
            } else {
                alert("You need Raw Wood to craft Planks.");
            }
        }

        function updatePlayer() {
            let centerX = Math.floor((player.x + player.width/2) / TILE_SIZE);
            let centerY = Math.floor((player.y + player.height/2) / TILE_SIZE);
            if (centerY >= 0 && centerY < ROWS && centerX >= 0 && centerX < COLS) {
                player.inWater = (world[centerY][centerX] === TILES.WATER);
            } else { player.inWater = false; }

            let atSurface = player.inWater && (getTileAt(player.x, player.y) === TILES.AIR);

            let moveSpeed = 5;
            if (keys['ArrowRight'] || keys['KeyD']) player.vx = moveSpeed;
            else if (keys['ArrowLeft'] || keys['KeyA']) player.vx = -moveSpeed;
            else player.vx = 0;

            let jumping = (keys['Space'] || keys['ArrowUp'] || keys['KeyW']);

            if (jumping) {
                if (atSurface) { player.vy = -10; } 
                else if (player.inWater) {
                    player.vy -= SWIM_FORCE; 
                    if (player.vy < -6) player.vy = -6;
                } else if (player.grounded) {
                    player.vy = -12; player.grounded = false;
                }
            }

            if (player.inWater) {
                if (!jumping) player.vy += BUOYANCY;
                player.vy += WATER_GRAVITY; player.vy *= WATER_DRAG; player.vx *= WATER_DRAG; 
            } else { player.vy += GRAVITY; }
            
            player.grounded = false;
            if (player.vx > 0) player.facingRight = true;
            if (player.vx < 0) player.facingRight = false;

            let nextX = player.x + player.vx;
            if (nextX < 0) nextX = 0; if (nextX > (COLS * TILE_SIZE) - player.width) nextX = (COLS * TILE_SIZE) - player.width;
            
            if (!checkCollision(nextX, player.y)) { player.x = nextX; } 
            else {
                if ((player.grounded || player.inWater) && !checkCollision(nextX, player.y - TILE_SIZE)) {
                    player.y -= TILE_SIZE; player.x = nextX;      
                }
            }

            let nextY = player.y + player.vy;
            if (nextY > ROWS * TILE_SIZE) { player.y = 0; player.vy = 0; nextY = 0; }

            if (player.vy > 0) { 
                if (checkCollision(player.x, nextY)) {
                    player.vy = 0; player.grounded = true;
                    player.y = Math.floor((nextY + player.height) / TILE_SIZE) * TILE_SIZE - player.height;
                } else { player.y = nextY; }
            } else if (player.vy < 0) { 
                 if (checkCollision(player.x, nextY, true)) { player.vy = 0; } else { player.y = nextY; }
            }

            camera.x += (player.x - canvas.width / 2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 0.1;
        }

        function checkCollision(x, y, headCheck=false) {
            let startX = Math.floor(x / TILE_SIZE);
            let endX = Math.floor((x + player.width - 0.1) / TILE_SIZE);
            let startY = Math.floor(y / TILE_SIZE);
            let endY = Math.floor((y + player.height - 0.1) / TILE_SIZE);
            if (headCheck) endY = startY;

            for (let r = startY; r <= endY; r++) {
                for (let c = startX; c <= endX; c++) {
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                        if (isSolid(world[r][c])) return true;
                    }
                }
            }
            return false;
        }

        // --- RENDER ---
        function getLightColor(tileType, row) {
            if (tileType === TILES.WATER) return 'rgba(41, 182, 246, 0.6)'; 
            const base = BASE_COLORS[tileType];
            if (!base) return 'magenta';

            let startShadow = ROWS * 0.75;
            if (row < startShadow) {
                return `hsl(${base[0]}, ${base[1]}%, ${base[2]}%)`;
            }
            let depth = row - startShadow;
            let maxDepth = ROWS - startShadow;
            let percent = depth / maxDepth; 
            let lightness = base[2] - (percent * (base[2] * 0.5)); 
            
            return `hsl(${base[0]}, ${base[1]}%, ${lightness}%)`;
        }

        function drawTile(r, c, tileType) {
            const x = c * TILE_SIZE;
            const y = r * TILE_SIZE;
            
            if (tileType >= 20 && tileType <= 34) {
                drawPlant(x, y, tileType);
                return;
            }

            let startShadow = ROWS * 0.75;
            let shade = 0;
            if (r > startShadow) {
                let depth = r - startShadow;
                let maxDepth = ROWS - startShadow;
                shade = (depth / maxDepth) * 0.85; 
            }

            function fill(color) {
                ctx.fillStyle = color;
                ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                if (shade > 0) {
                    ctx.fillStyle = `rgba(0,0,0,${shade})`;
                    ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE);
                }
            }

            // TEXTURES
            if (tileType === TILES.DIRT) {
                fill(getLightColor(1, r)); ctx.fillStyle = "rgba(0,0,0,0.2)";
                let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4);
            }
            else if (tileType === TILES.GRASS) {
                fill(getLightColor(1, r)); ctx.fillStyle = getLightColor(2, r-5);
                ctx.fillRect(x, y, TILE_SIZE, 10);
                ctx.fillRect(x+2, y, 4, 12); ctx.fillRect(x+10, y, 4, 14); ctx.fillRect(x+20, y, 4, 11);
            }
            else if (tileType === TILES.STONE) {
                fill(getLightColor(3, r)); ctx.fillStyle = "rgba(0,0,0,0.3)";
                if((c+r)%2===0) ctx.fillRect(x+16, y, 2, 16); else ctx.fillRect(x+16, y+16, 2, 16);
                ctx.fillRect(x, y+16, TILE_SIZE, 2);
            }
            else if (tileType === TILES.WOOD) {
                fill(getLightColor(7, r)); ctx.fillStyle = "rgba(40, 20, 0, 0.4)";
                ctx.fillRect(x+6, y, 4, TILE_SIZE); ctx.fillRect(x+18, y, 2, TILE_SIZE); ctx.fillRect(x+26, y, 4, TILE_SIZE);
            }
            else if (tileType === TILES.PLANKS) {
                fill(getLightColor(12, r)); ctx.fillStyle = "rgba(0,0,0,0.3)";
                for(let i=1; i<4; i++) ctx.fillRect(x, y + (i*8), TILE_SIZE, 2);
                ctx.fillStyle = "rgba(0,0,0,0.6)"; 
                ctx.fillRect(x+2, y+3, 2, 2); ctx.fillRect(x+28, y+3, 2, 2);
                ctx.fillRect(x+2, y+11, 2, 2); ctx.fillRect(x+28, y+11, 2, 2);
            }
            else if (tileType === TILES.LEAVES) {
                fill(getLightColor(8, r)); ctx.fillStyle = "#66bb6a"; 
                ctx.fillRect(x+4, y+4, 8, 6); ctx.fillRect(x+18, y+18, 6, 8);
            }
            else if (tileType === TILES.SAND) {
                fill(getLightColor(4, r)); ctx.fillStyle = "rgba(200, 150, 0, 0.2)"; 
                let n = (c * r * 13) % 10; if(n<3) ctx.fillRect(x+4, y+4, 4, 4); if(n>6) ctx.fillRect(x+20, y+20, 4, 4);
            }
            else if (tileType === TILES.SNOW) {
                // UPDATED SNOW: Matches Dirt base
                fill(getLightColor(1, r)); // Dirt base color
                ctx.fillStyle = "rgba(0,0,0,0.2)"; // Dirt specks
                let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4);
                
                // Snow Top
                ctx.fillStyle = "#ffffff";
                ctx.fillRect(x, y, TILE_SIZE, 10);
                ctx.fillRect(x+2, y, 4, 12); ctx.fillRect(x+10, y, 4, 14); ctx.fillRect(x+20, y, 4, 11);
            }
            else if (tileType === TILES.WATER) {
                ctx.fillStyle = "rgba(41, 182, 246, 0.6)"; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                ctx.fillStyle = "rgba(255, 255, 255, 0.3)";
                ctx.fillRect(x+4, y+4, 8, 2); ctx.fillRect(x+16, y+10, 10, 2);
            }
            else if (tileType === TILES.MUD) {
                fill(getLightColor(6, r)); ctx.fillStyle = "rgba(0,0,0,0.35)"; // Mud specks
                let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4);
            }
            else if (tileType === TILES.COAL_ORE) {
                drawTile(r, c, TILES.STONE); ctx.fillStyle = "#111";
                ctx.beginPath(); ctx.arc(x+16, y+16, 6, 0, 2*Math.PI); ctx.fill();
            }
            else if (tileType === TILES.GOLD_ORE) {
                drawTile(r, c, TILES.STONE); ctx.fillStyle = "#ffd700";
                ctx.fillRect(x+10, y+10, 12, 12); ctx.fillStyle="#fff"; ctx.fillRect(x+12,y+12,4,4);
            }
            else if (tileType === TILES.DIAMOND_ORE) {
                drawTile(r, c, TILES.STONE); ctx.fillStyle = "#00e5ff"; 
                ctx.beginPath(); ctx.moveTo(x+16, y+8); ctx.lineTo(x+24, y+16); ctx.lineTo(x+16, y+24); ctx.lineTo(x+8, y+16); ctx.fill();
            }
        }

        function drawPlant(x, y, id) {
            let variant = id % 5;
            if (id >= 20 && id <= 24) { 
                ctx.fillStyle = "#2e7d32"; ctx.fillRect(x+14, y+16, 4, 16);
                const colors = ["#e91e63", "#9c27b0", "#ffeb3b", "#2196f3", "#f44336"];
                ctx.fillStyle = colors[variant]; ctx.fillRect(x+10, y+10, 12, 12); 
                ctx.fillStyle = "white"; ctx.fillRect(x+14, y+14, 4, 4);
            }
            else if (id >= 25 && id <= 29) { 
                if (variant < 3) {
                    ctx.fillStyle = "#558b2f"; ctx.fillRect(x+12, y+8, 8, 24);
                    if(variant==1) ctx.fillRect(x+6, y+14, 6, 4);
                } else {
                    ctx.fillStyle = "#795548"; ctx.fillRect(x+14, y+20, 4, 12); ctx.fillRect(x+10, y+16, 12, 2);
                }
            }
            else if (id >= 30 && id <= 34) { 
                ctx.fillStyle = "#81d4fa"; ctx.fillRect(x+14, y+16, 4, 16);
                ctx.fillStyle = "#e1f5fe"; ctx.fillRect(x+12, y+10, 8, 8);
            }
        }

        function drawPlayer() {
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(player.x, player.y, player.width, 12); 
            ctx.fillStyle = '#000'; 
            let eyeX = player.facingRight ? player.x + 14 : player.x + 2;
            ctx.fillRect(eyeX, player.y + 4, 4, 4);
            if (player.inWater) {
                ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(player.x - 4, player.y + 10, 4, 4);
            }
        }

        function draw() {
            let grad = ctx.createLinearGradient(0, -camera.y, 0, (ROWS*TILE_SIZE) - camera.y);
            grad.addColorStop(0, "#87CEEB"); grad.addColorStop(0.5, "#bdc3c7"); grad.addColorStop(1, "#1a252f");
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(Math.round(-camera.x), Math.round(-camera.y));

            let startCol = Math.floor(camera.x / TILE_SIZE) - 2;
            let endCol = startCol + (canvas.width / TILE_SIZE) + 4;
            let startRow = Math.floor(camera.y / TILE_SIZE) - 2;
            let endRow = startRow + (canvas.height / TILE_SIZE) + 4;

            for (let r = startRow; r < endRow; r++) {
                for (let c = startCol; c < endCol; c++) {
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                        if (world[r][c] !== TILES.AIR) drawTile(r, c, world[r][c]);
                    }
                }
            }
            drawPlayer();
            if (mouseTile.c >= 0) {
                ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth = 2;
                ctx.strokeRect(mouseTile.c*TILE_SIZE, mouseTile.r*TILE_SIZE, TILE_SIZE, TILE_SIZE);
            }
            ctx.restore();
            requestAnimationFrame(loop);
        }

        function loop() {
            tickCount++;
            updatePlayer();
            if (tickCount % 2 === 0) updateCellularAutomata();
            draw();
        }

        // --- CONTROLS ---
        function updateHUD() {
            const toolDiv = document.getElementById('tool-display');
            toolDiv.innerText = mode === 'MINE' ? "‚õèÔ∏è MINING" : "üß± BUILDING";
            toolDiv.style.color = mode === 'MINE' ? "#ff7675" : "#55efc4";

            const invBar = document.getElementById('inventory-bar');
            invBar.innerHTML = '';
            
            const showList = [TILES.DIRT, TILES.GRASS, TILES.STONE, TILES.SAND, TILES.MUD, TILES.WOOD, TILES.PLANKS, TILES.LEAVES, TILES.WATER, TILES.SNOW, TILES.COAL_ORE, TILES.GOLD_ORE, TILES.DIAMOND_ORE];
            for(let i=20; i<=34; i++) { if(inventory[i]>0) showList.push(i); }

            showList.forEach(id => {
                const slot = document.createElement('div');
                let className = 'inv-slot ';
                if(id < 20) className += 'icon-' + id;
                else className += 'icon-' + id; // NEW: Use ID specific class for flowers
                
                slot.className = className + (selectedBlock === id ? ' selected' : '');
                slot.innerHTML = `<span>${inventory[id]}</span>`;
                slot.title = "ID: " + id;
                slot.onclick = () => { selectedBlock = id; mode = 'BUILD'; updateHUD(); };
                invBar.appendChild(slot);
            });
        }

        const keys = {};
        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'KeyE') { mode = mode === 'MINE' ? 'BUILD' : 'MINE'; updateHUD(); }
            if (e.code === 'KeyC') { craftPlanks(); }
            if (e.key >= '1' && e.key <= '9') {
                const map = [0, TILES.DIRT, TILES.GRASS, TILES.STONE, TILES.SAND, TILES.MUD, TILES.WOOD, TILES.PLANKS, TILES.LEAVES, TILES.WATER, TILES.SNOW];
                if (map[e.key]) { selectedBlock = map[e.key]; mode = 'BUILD'; updateHUD(); }
            }
        });
        window.addEventListener('keyup', e => { keys[e.code] = false; });

        canvas.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            mouseTile.c = Math.floor((e.clientX - r.left + camera.x) / TILE_SIZE);
            mouseTile.r = Math.floor((e.clientY - r.top + camera.y) / TILE_SIZE);
        });
        canvas.addEventListener('mousedown', e => {
            const c = mouseTile.c, r = mouseTile.r;
            if (r>=0 && r<ROWS && c>=0 && c<COLS) {
                 if (mode === 'MINE') {
                    let t = world[r][c];
                    if (t !== TILES.AIR) { 
                        inventory[t]++; world[r][c] = TILES.AIR; updateHUD(); 
                    }
                 } else {
                     let pC = Math.floor((player.x+10)/TILE_SIZE);
                     let pR = Math.floor((player.y+20)/TILE_SIZE);
                     if ((c !== pC || r !== pR) && world[r][c] === TILES.AIR && inventory[selectedBlock] > 0) {
                         world[r][c] = selectedBlock; inventory[selectedBlock]--; updateHUD();
                     }
                 }
            }
        });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        function openModal() { document.getElementById('modal-overlay').style.display = 'flex'; }
        function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
        function confirmNewWorld(w, h) {
            initWorld(w, h); inventory = {}; Object.values(TILES).forEach(v => { if(v!==0) inventory[v]=0; }); closeModal();
        }
        function saveGame() {
            localStorage.setItem('vivaria_v18', JSON.stringify({ world, player, inventory, COLS, ROWS })); alert("Saved!");
        }
        function loadGame() {
            const data = JSON.parse(localStorage.getItem('vivaria_v18'));
            if (data) { COLS = data.COLS; ROWS = data.ROWS; world = data.world; player = data.player; inventory = data.inventory; updateHUD(); alert("Loaded!"); }
        }

        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        initWorld(COLS, ROWS);
        loop();
    </script>
</body>
</html>

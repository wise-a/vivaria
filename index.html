<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vivaria v7.0 - Craft-Ability</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <style>
        :root {
            --pixel-font: 'Press Start 2P', cursive;
            --ui-bg: rgba(20, 20, 30, 0.95);
            --ui-border: #4a69bd;
            --highlight: #f1c40f;
            --admin-color: #e74c3c;
        }
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            color: white;
            font-family: var(--pixel-font);
            display: flex;
            flex-direction: column;
            align-items: center;
            user-select: none;
        }

        #ui-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            pointer-events: none; z-index: 10;
            display: flex; flex-direction: column; justify-content: space-between;
            padding: 20px; box-sizing: border-box;
        }

        .hud-panel {
            background: var(--ui-bg); padding: 12px;
            border-radius: 4px; border: 3px solid var(--ui-border);
            pointer-events: auto; box-shadow: 0 4px 8px rgba(0,0,0,0.6);
        }

        #inventory-bar { 
            display: flex; gap: 4px; margin-top: 10px; flex-wrap: wrap; 
            max-width: 500px; max-height: 150px; overflow-y: auto;
        }
        .inv-slot {
            width: 30px; height: 30px; background-color: rgba(0,0,0,0.5);
            border: 2px solid #555; position: relative; cursor: pointer; transition: transform 0.1s;
        }
        .inv-slot:hover { transform: scale(1.1); border-color: white; }
        .inv-slot span {
            position: absolute; bottom: 1px; right: 2px;
            font-size: 7px; color: white; text-shadow: 1px 1px 0 #000;
        }
        .selected { border-color: var(--highlight); box-shadow: 0 0 8px var(--highlight); }

        /* --- ICONS --- */
        .icon-1 { background: #5d4037; } 
        .icon-2 { background: linear-gradient(#4caf50, #5d4037); } 
        .icon-8 { background: #2e7d32; } 
        .icon-11 { background: linear-gradient(#ffffff, #5d4037); }

        .icon-3 { background-color: #78909c; background-image: linear-gradient(335deg, rgba(0,0,0,0.3) 23px, transparent 23px), linear-gradient(155deg, rgba(0,0,0,0.3) 23px, transparent 23px); background-size: 18px 18px; }
        .icon-4 { background-color: #fdd835; background-image: radial-gradient(#fbc02d 15%, transparent 16%); background-size: 8px 8px; }
        .icon-5 { background-color: #29b6f6; background-image: repeating-linear-gradient(45deg, transparent, transparent 5px, rgba(255,255,255,0.3) 5px, rgba(255,255,255,0.3) 10px); }
        .icon-6 { background-color: #4a332a; background-image: linear-gradient(rgba(0,0,0,0.1) 2px, transparent 2px), linear-gradient(90deg, rgba(0,0,0,0.1) 2px, transparent 2px); background-size: 16px 16px; }
        .icon-7 { background-color: #5d4037; background-image: repeating-linear-gradient(90deg, transparent, transparent 4px, #3e2723 4px, #3e2723 8px); }
        .icon-12 { background-color: #a1887f; background-image: repeating-linear-gradient(0deg, transparent, transparent 8px, #5d4037 8px, #5d4037 10px); border: 2px solid #5d4037; }
        .icon-9 { background: radial-gradient(circle, #000 30%, #78909c 35%); } 
        .icon-10 { background: radial-gradient(circle, #ffd700 30%, #78909c 35%); } 
        .icon-13 { background: radial-gradient(circle, #00e5ff 30%, #78909c 35%); } 
        .icon-14 { background: #a5d8f3; border: 2px solid #e1f5fe; opacity: 0.9; }
        .icon-15 { background: radial-gradient(circle at center top, #ffeb3b, #f57c00); border-bottom: 4px solid #5d4037; }
        .icon-16 { background: #000; position:relative; } /* Stick */
        .icon-16::after { content:''; position:absolute; top:4px; left:14px; width:4px; height:22px; background:#795548; transform: rotate(15deg); }
        .icon-17 { background: radial-gradient(circle, #ff5722 20%, #3e2723 70%); border: 2px solid #ff9800; } /* Campfire */

        /* TOOLS */
        .icon-40, .icon-41, .icon-42, .icon-43, .icon-44 { position: relative; background: rgba(0,0,0,0.3); }
        .icon-40::before, .icon-41::before, .icon-42::before, .icon-43::before, .icon-44::before {
            content:''; position:absolute; bottom:6px; left:6px; width:4px; height:18px;
            background:#795548; transform: rotate(-45deg); transform-origin: bottom left; border-radius: 2px;
        }
        .icon-40::after, .icon-41::after, .icon-42::after, .icon-43::after, .icon-44::after {
             content:''; position:absolute; top:4px; left:4px; width:22px; height:22px;
             border-top: 4px solid currentColor; border-left: 4px solid currentColor;
             border-top-left-radius: 8px; transform: rotate(-15deg); background: transparent; box-shadow: none;
             color: inherit;
        }

        .icon-40 { color: #8d6e63; }
        .icon-41 { color: #9e9e9e; }
        .icon-42 { color: #e0e0e0; }
        .icon-43 { color: #fdd835; }
        .icon-44 { color: #00e5ff; }

        /* Flower Icons */
        .icon-20 { background: radial-gradient(circle, #e91e63 40%, #2e7d32 50%); } 
        .icon-21 { background: radial-gradient(circle, #9c27b0 40%, #2e7d32 50%); } 
        .icon-22 { background: radial-gradient(circle, #ffeb3b 40%, #2e7d32 50%); } 
        .icon-23 { background: radial-gradient(circle, #2196f3 40%, #2e7d32 50%); } 
        .icon-24 { background: radial-gradient(circle, #f44336 40%, #2e7d32 50%); } 
        .icon-25 { background: linear-gradient(to top, #558b2f, #8bc34a); border-radius: 4px; } 
        .icon-26 { background: linear-gradient(to top, #33691e, #558b2f); border-radius: 4px; }
        .icon-27 { background: linear-gradient(to top, #558b2f, #fdd835); border-radius: 4px; }
        .icon-28 { background: repeating-linear-gradient(45deg, #795548, #795548 2px, transparent 2px, transparent 4px); } 
        .icon-29 { background: radial-gradient(circle, #795548 30%, transparent 35%); }
        .icon-30 { background: radial-gradient(circle, #81d4fa 40%, white 50%); }
        .icon-31 { background: radial-gradient(circle, #4fc3f7 40%, white 50%); }
        .icon-32 { background: linear-gradient(to top, #81d4fa, white); border-radius: 50%; }
        .icon-33 { background: #b3e5fc; border: 2px solid white; }
        .icon-34 { background: radial-gradient(circle, white 20%, #81d4fa 80%); }

        /* OVERLAYS */
        #modal-overlay, #lan-overlay, #crafting-overlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.85); display: none;
            justify-content: center; align-items: center; pointer-events: auto; z-index: 20;
        }
        .modal-box { background: var(--ui-bg); border: 4px solid var(--highlight); padding: 20px; text-align: center; min-width: 350px; max-width: 500px; max-height: 80vh; overflow-y: auto; }
        
        .size-btn {
            display: block; width: 100%; margin: 10px 0; padding: 15px;
            font-family: var(--pixel-font); background: #34495e; color: white;
            border: 2px solid #fff; cursor: pointer;
        }
        .size-btn:hover { background: var(--highlight); color: black; }

        .btn-group { display:flex; gap: 5px; margin-top: 5px;}
        button {
            font-family: var(--pixel-font); background: #34495e; border: 2px solid #bdc3c7;
            color: white; padding: 10px 15px; font-size: 10px; cursor: pointer;
        }
        button:hover { background: #2c3e50; border-color: var(--highlight); }

        .craft-btn { background: #e67e22; border-color: #d35400; width: 100%; margin-top:5px; display: block; }
        .craft-btn:hover { background: #d35400; }

        /* CRAFTING UI */
        .recipe-row { display: flex; align-items: center; justify-content: space-between; background: rgba(0,0,0,0.3); padding: 10px; margin-bottom: 5px; border: 1px solid #555; }
        .recipe-info { text-align: left; font-size: 10px; color: #ddd; }
        .recipe-input { width: 50px; background: #222; color: white; border: 1px solid #777; font-family: inherit; font-size: 10px; padding: 5px; text-align: center; }
        .recipe-btn { background: #27ae60; border-color: #2ecc71; padding: 5px 10px; margin-left: 5px; }

        #file-input { display: none; }
        input[type="text"], input[type="password"] { padding: 10px; font-family: inherit; width: 90%; margin-bottom: 10px; background: #222; color: white; border: 1px solid #777; }

        canvas { display: block; cursor: crosshair; }
        ::-webkit-scrollbar { width: 5px; }
        ::-webkit-scrollbar-thumb { background: #f1c40f; }
    </style>
</head>
<body>

    <div id="modal-overlay">
        <div class="modal-box">
            <h2 style="color: #f1c40f; margin-bottom: 20px;">NEW WORLD</h2>
            <button class="size-btn" onclick="confirmNewWorld(150, 60)">STANDARD (150x60)</button>
            <button class="size-btn" onclick="confirmNewWorld(300, 100)">LARGE (300x100)</button>
            <button class="size-btn" onclick="confirmNewWorld(600, 150)">MASSIVE (600x150)</button>
            <button class="size-btn" style="background:#c0392b" onclick="closeModal()">CANCEL</button>
        </div>
    </div>

    <div id="lan-overlay">
        <div class="modal-box">
             <h2 style="color: #bdc3c7; margin-bottom: 20px;">MULTIPLAYER</h2>
             <p>Multiplayer is currently under maintenance.</p>
            <button class="size-btn" style="background:#c0392b; margin-top: 20px;" onclick="document.getElementById('lan-overlay').style.display='none'">CLOSE</button>
        </div>
    </div>

    <div id="crafting-overlay">
        <div class="modal-box" style="width: 500px;">
            <h2 style="color: #e67e22; margin-bottom: 20px;">CRAFTING TABLE</h2>
            <div id="crafting-list">
                </div>
            <button class="size-btn" style="background:#c0392b; margin-top: 20px;" onclick="document.getElementById('crafting-overlay').style.display='none'">CLOSE (ESC)</button>
        </div>
    </div>

    <div id="ui-layer">
        <div class="top-bar" style="display:flex; justify-content:space-between; align-items: flex-start;">
            <div class="hud-panel">
                <h1 style="font-size: 16px; margin:0 0 10px 0; color: #f1c40f;">VIVARIA v7.0</h1>
                <div id="tool-display" style="color: #ff7675; font-size: 12px; margin-bottom:5px;">⛏️ MINING</div>
                <div id="inventory-bar"></div>
            </div>
            
            <div class="hud-panel" style="text-align: right; display: flex; flex-direction: column; align-items: flex-end;">
                <canvas id="clockCanvas" width="50" height="50" style="background:#222; border-radius:50%; border:2px solid #f1c40f; margin-bottom:5px;"></canvas>
                <div style="font-size: 8px; color: #f1c40f; margin-bottom: 10px;" id="time-display">12:00 PM</div>
                
                <div style="font-size: 10px; color: #bdc3c7; line-height: 1.6;">
                    [Arrows] Move<br>[Space] Jump<br>[E] Mode<br>[C] Crafting
                </div>
                <button class="craft-btn" onclick="openCraftingMenu()">Open Crafting</button>
            </div>
        </div>
        <div style="align-self: flex-end; pointer-events: auto; display: flex; flex-direction: column; align-items: flex-end;">
            <div class="btn-group">
                <button onclick="openLanMenu()" style="border-color: #bdc3c7; color: #bdc3c7;">Multiplayer</button>
                <button onclick="openModal()">New World</button>
            </div>
            <div class="btn-group">
                <button onclick="saveGame()">Save</button>
                <button onclick="loadGame()">Load</button>
                <button onclick="exportSave()">Export</button>
                <button onclick="document.getElementById('file-input').click()">Import</button>
                <input type="file" id="file-input" accept=".json" onchange="importSave(this)">
            </div>
        </div>
    </div>
    
    <canvas id="gameCanvas"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        ctx.imageSmoothingEnabled = false;

        let COLS = 150; 
        let ROWS = 60; 
        const TILE_SIZE = 32;

        const GRAVITY = 0.5;
        const WATER_GRAVITY = 0.1;
        const WATER_DRAG = 0.92; 
        const SWIM_FORCE = 1.5; 
        const BUOYANCY = -0.15; 
        
        const TILES = { 
            AIR: 0, DIRT: 1, GRASS: 2, STONE: 3, SAND: 4, WATER: 5, MUD: 6,
            WOOD: 7, LEAVES: 8, COAL_ORE: 9, GOLD_ORE: 10, SNOW: 11, PLANKS: 12, DIAMOND_ORE: 13,
            ICE: 14, TORCH: 15, STICK: 16, CAMPFIRE: 17,
            WOOD_PICK: 40, STONE_PICK: 41, IRON_PICK: 42, GOLD_PICK: 43, DIAMOND_PICK: 44
        };

        const TOOLS = {
            [TILES.WOOD_PICK]: { id: TILES.WOOD_PICK, power: 2, durability: 30, color: '#8d6e63' },
            [TILES.STONE_PICK]: { id: TILES.STONE_PICK, power: 4, durability: 60, color: '#9e9e9e' },
            [TILES.IRON_PICK]: { id: TILES.IRON_PICK, power: 6, durability: 120, color: '#e0e0e0' },
            [TILES.GOLD_PICK]: { id: TILES.GOLD_PICK, power: 12, durability: 20, color: '#fdd835' },
            [TILES.DIAMOND_PICK]: { id: TILES.DIAMOND_PICK, power: 10, durability: 500, color: '#00e5ff' }
        };

        const TILE_HARDNESS = {
            [TILES.DIRT]: 10, [TILES.GRASS]: 10, [TILES.SAND]: 10, [TILES.SNOW]: 10, [TILES.MUD]: 10,
            [TILES.WOOD]: 20, [TILES.PLANKS]: 20, [TILES.LEAVES]: 5,
            [TILES.STONE]: 30, [TILES.COAL_ORE]: 30, [TILES.GOLD_ORE]: 40, [TILES.DIAMOND_ORE]: 50,
            [TILES.ICE]: 15
        };

        const TILE_NAMES = {
            1: "Dirt", 2: "Grass Block", 3: "Stone", 4: "Sand", 5: "Water Bucket", 6: "Mud",
            7: "Raw Wood", 8: "Leaves", 9: "Coal Ore", 10: "Gold Ore", 11: "Snow Block",
            12: "Wood Planks", 13: "Diamond Ore", 14: "Ice Block", 15: "Torch",
            16: "Stick", 17: "Campfire",
            40: "Wood Pickaxe", 41: "Stone Pickaxe", 42: "Iron Pickaxe", 43: "Gold Pickaxe", 44: "Diamond Pickaxe",
            20: "Rose", 21: "Lavender", 22: "Sunflower", 23: "Bluebell", 24: "Tulip",
            25: "Cactus", 26: "Tall Cactus", 27: "Shrub", 28: "Dead Bush", 29: "Tumbleweed",
            30: "Frost Flower", 31: "Winter Bush", 32: "Snow Berry", 33: "Icicle Plant", 34: "Glacier Lily"
        };

        const BASE_COLORS = {
            1: [28, 45, 30], 2: [100, 60, 35], 3: [210, 10, 50], 4: [45, 90, 60], 
            6: [25, 35, 25], 7: [30, 55, 30], 8: [120, 50, 35], 9: [0, 0, 20], 
            10: [50, 100, 50], 11: [200, 30, 90], 12: [35, 50, 50], 13: [180, 80, 60],
            14: [195, 70, 80], 15: [40, 100, 50], 16: [30, 40, 30], 17: [20, 20, 20]
        };

        const RECIPES = [
            { id: 'planks', name: "Wood Planks", out: TILES.PLANKS, count: 4, cost: [{id: TILES.WOOD, count: 1}] },
            { id: 'sticks', name: "Sticks", out: TILES.STICK, count: 10, cost: [{id: TILES.WOOD, count: 1}] },
            { id: 'torches', name: "Torches", out: TILES.TORCH, count: 8, cost: [{id: TILES.PLANKS, count: 1}, {id: TILES.COAL_ORE, count: 1}] },
            { id: 'campfire', name: "Campfire", out: TILES.CAMPFIRE, count: 1, cost: [{id: TILES.TORCH, count: 1}, {id: TILES.STICK, count: 2}] },
            { id: 'wood_pick', name: "Wood Pickaxe", out: TILES.WOOD_PICK, count: 1, cost: [{id: TILES.WOOD, count: 3}, {id: TILES.STICK, count: 2}] },
            { id: 'stone_pick', name: "Stone Pickaxe", out: TILES.STONE_PICK, count: 1, cost: [{id: TILES.STONE, count: 3}, {id: TILES.STICK, count: 2}] }
        ];
        
        let world = [];
        let player = { x: 0, y: 0, width: 20, height: 44, vx: 0, vy: 0, grounded: false, facingRight: true, inWater: false, id: Math.random().toString(36).substr(2, 9), activeTool: null, currentToolDurability: 0 };
        let torchList = []; 

        let channel = null; let otherPlayers = {}; let isAdmin = false;

        let camera = { x: 0, y: 0 };
        let mouseTile = { c: -1, r: -1 };
        let inventory = {}; 
        Object.values(TILES).forEach(v => { if(v !== 0) inventory[v] = 0; });
        for(let i=20; i<=34; i++) inventory[i] = 0; 
        
        let selectedBlock = TILES.DIRT;
        let mode = 'MINE'; 
        let isMining = false;
        let miningProgress = 0;
        let currentMiningTarget = { r: -1, c: -1 };
        let tickCount = 0;
        let worldSeed = Math.random() * 10000;

        // --- ATMOSPHERE VARIABLES ---
        let worldTime = 6000; 
        const DAY_LENGTH = 24000;
        let globalLightLevel = 1.0; 
        let clouds = [];
        let fog = [];
        let skyColors = {
            day: [135, 206, 235], dusk: [255, 160, 122], night: [25, 25, 112], dawn: [255, 228, 181]
        };
        let currentSky = skyColors.day;

        function initAtmosphere() {
            clouds = [];
            for(let i=0; i<15; i++) {
                clouds.push({
                    x: Math.random() * COLS * TILE_SIZE,
                    y: Math.random() * (ROWS * TILE_SIZE * 0.2), 
                    width: 100 + Math.random() * 200,
                    height: 40 + Math.random() * 60,
                    speed: 0.05 + Math.random() * 0.1, 
                    opacity: 0.3 + Math.random() * 0.3 
                });
            }
            fog = [];
             for(let i=0; i<20; i++) {
                fog.push({
                    x: Math.random() * COLS * TILE_SIZE,
                    y: (ROWS * TILE_SIZE * 0.6) + Math.random() * (ROWS * TILE_SIZE * 0.4),
                    width: 300 + Math.random() * 500,
                    height: 30 + Math.random() * 50,
                    speed: -0.1 - Math.random() * 0.2,
                    opacity: 0.1 + Math.random() * 0.2
                });
            }
        }

        function updateAtmosphere() {
            worldTime = (worldTime + 1) % DAY_LENGTH;
            if (worldTime < 2000) { let t = worldTime / 2000; globalLightLevel = lerp(0.6, 1.0, t); currentSky = lerpColor(skyColors.dawn, skyColors.day, t); } 
            else if (worldTime < 10000) { globalLightLevel = 1.0; currentSky = skyColors.day; } 
            else if (worldTime < 12000) { let t = (worldTime - 10000) / 2000; globalLightLevel = lerp(1.0, 0.8, t); currentSky = lerpColor(skyColors.day, skyColors.dusk, t); } 
            else if (worldTime < 14000) { let t = (worldTime - 12000) / 2000; globalLightLevel = lerp(0.8, 0.5, t); currentSky = lerpColor(skyColors.dusk, skyColors.night, t); } 
            else if (worldTime < 22000) { globalLightLevel = 0.5; currentSky = skyColors.night; } 
            else { let t = (worldTime - 22000) / 2000; globalLightLevel = lerp(0.5, 0.6, t); currentSky = lerpColor(skyColors.night, skyColors.dawn, t); }

            if (tickCount % 60 === 0) {
                let hour = Math.floor(worldTime / 1000); let ampm = hour >= 12 ? "PM" : "AM"; hour = hour % 12; if(hour === 0) hour = 12;
                let day = Math.floor(tickCount / DAY_LENGTH) + 1;
                document.getElementById('time-display').innerText = `Day ${day} - ${hour}:00 ${ampm}`;
            }

            clouds.forEach(c => { c.x += c.speed; if (c.x > COLS * TILE_SIZE) c.x = -c.width; });
            fog.forEach(f => { f.x += f.speed; if (f.x + f.width < 0) f.x = COLS * TILE_SIZE; });
        }

        function drawClock() {
            const c = document.getElementById('clockCanvas');
            const cx = c.getContext('2d');
            cx.clearRect(0,0,50,50);
            const centerX = 25; const centerY = 25; const radius = 22;
            cx.fillStyle = `rgb(${currentSky[0]}, ${currentSky[1]}, ${currentSky[2]})`;
            cx.beginPath(); cx.arc(centerX, centerY, radius, 0, Math.PI*2); cx.fill();
            let angle = ((worldTime / DAY_LENGTH) * 2 * Math.PI) + Math.PI;
            let sunX = centerX + Math.cos(angle) * 16; let sunY = centerY + Math.sin(angle) * 16;
            cx.fillStyle = "#f1c40f"; cx.beginPath(); cx.arc(sunX, sunY, 5, 0, Math.PI*2); cx.fill();
            let moonX = centerX + Math.cos(angle + Math.PI) * 16; let moonY = centerY + Math.sin(angle + Math.PI) * 16;
            cx.fillStyle = "#ecf0f1"; cx.beginPath(); cx.arc(moonX, moonY, 4, 0, Math.PI*2); cx.fill();
        }
        
        function lerp(start, end, t) { return start * (1 - t) + end * t; }
        function lerpColor(c1, c2, t) { return [ Math.round(lerp(c1[0], c2[0], t)), Math.round(lerp(c1[1], c2[1], t)), Math.round(lerp(c1[2], c2[2], t)) ]; }
        
        function isPermeable(tile) { return tile === TILES.TORCH || tile === TILES.STICK || (tile >= 20 && tile <= 34); }
        function isSolid(tile) { 
            if (tile === TILES.AIR) return false;
            if (tile === TILES.WATER) return false;
            if (isPermeable(tile)) return false;
            if (tile === TILES.WOOD || tile === TILES.LEAVES) return false; 
            return true; 
        }
        
        function openLanMenu() { document.getElementById('lan-overlay').style.display = 'flex'; }

        // --- CRAFTING SYSTEM ---
        function openCraftingMenu() {
            const list = document.getElementById('crafting-list');
            list.innerHTML = '';
            RECIPES.forEach((r, index) => {
                let costStr = r.cost.map(c => `${c.count} ${TILE_NAMES[c.id]}`).join(" + ");
                let html = `
                <div class="recipe-row">
                    <div class="recipe-info">
                        <strong style="color:#f1c40f; font-size:12px;">${r.name} x${r.count}</strong><br>
                        Req: ${costStr}
                    </div>
                    <div style="display:flex; align-items:center;">
                        <input type="number" id="craft-amount-${index}" class="recipe-input" value="1" min="1">
                        <button class="recipe-btn" onclick="craftItem(${index})">CRAFT</button>
                    </div>
                </div>`;
                list.innerHTML += html;
            });
            document.getElementById('crafting-overlay').style.display = 'flex';
        }

        function craftItem(recipeIndex) {
            const recipe = RECIPES[recipeIndex];
            const amountInput = document.getElementById(`craft-amount-${recipeIndex}`);
            let multiplier = parseInt(amountInput.value);
            if (isNaN(multiplier) || multiplier < 1) multiplier = 1;

            // Check resources
            let canCraft = true;
            for (let c of recipe.cost) {
                if (inventory[c.id] < c.count * multiplier) {
                    canCraft = false;
                    alert(`Not enough ${TILE_NAMES[c.id]}! Need ${c.count * multiplier}.`);
                    break;
                }
            }

            if (canCraft) {
                // Deduct resources
                for (let c of recipe.cost) {
                    inventory[c.id] -= c.count * multiplier;
                }
                // Add output
                inventory[recipe.out] += recipe.count * multiplier;
                updateHUD();
                alert(`Crafted ${recipe.count * multiplier} ${recipe.name}!`);
            }
        }

        // --- WORLD GENERATION ---
        function initWorld(w, h) {
            COLS = w; ROWS = h;
            world = []; torchList = []; worldSeed = Math.random() * 10000; 
            let surfaceLevel = Math.floor(ROWS * 0.35);
            let heights = new Array(COLS).fill(0);
            let biomes = new Array(COLS).fill('');

            for (let r = 0; r < ROWS; r++) {
                let row = [];
                for (let c = 0; c < COLS; c++) {
                    let cx = c + worldSeed; 
                    let heightNoise = Math.sin(cx * 0.04) * 5 + Math.sin(cx * 0.1) * 2;
                    let actualSurface = Math.floor(surfaceLevel + heightNoise);
                    if (r === 0) heights[c] = actualSurface;

                    let biomeNoise = Math.sin(cx * 0.015) + (Math.sin(cx * 0.05) * 0.1); 
                    let surfaceBlock, subBlock;

                    if (biomeNoise > 0.4 && biomeNoise < 0.6) { biomes[c] = 'DESERT'; surfaceBlock = (Math.random()>0.5?TILES.SAND:TILES.GRASS); subBlock = (surfaceBlock===TILES.SAND?TILES.SAND:TILES.DIRT); }
                    else if (biomeNoise < -0.4 && biomeNoise > -0.6) { biomes[c] = 'SNOW'; surfaceBlock = (Math.random()>0.5?TILES.SNOW:TILES.GRASS); subBlock = TILES.DIRT; }
                    else if (biomeNoise > 0.5) { biomes[c] = 'DESERT'; surfaceBlock = TILES.SAND; subBlock = TILES.SAND; }
                    else if (biomeNoise < -0.5) { biomes[c] = 'SNOW'; surfaceBlock = TILES.SNOW; subBlock = TILES.DIRT; }
                    else { biomes[c] = 'FOREST'; surfaceBlock = TILES.GRASS; subBlock = TILES.DIRT; }

                    if (r < actualSurface) { row.push(TILES.AIR); }
                    else if (r === actualSurface) { row.push(surfaceBlock); }
                    else if (r > actualSurface && r < actualSurface + 15) { row.push(subBlock); }
                    else {
                        let rand = Math.random();
                        if (rand < 0.015) row.push(TILES.COAL_ORE);
                        else if (rand < 0.018 && r > actualSurface + 25) row.push(TILES.GOLD_ORE);
                        else if (rand < 0.019 && r > ROWS - 15) row.push(TILES.DIAMOND_ORE); 
                        else row.push(TILES.STONE);
                    }
                }
                world.push(row);
            }

            for(let i=0; i < COLS/40; i++) { let lakeX = Math.floor(Math.random() * (COLS - 20)) + 10; carveLake(lakeX, heights[lakeX]); }
            
            for (let c=0; c < COLS; c++) {
                if (biomes[c] === 'SNOW') {
                    let h = heights[c];
                    for(let r=h-5; r<h+5; r++) {
                        if (r>=0 && r<ROWS && world[r][c] === TILES.WATER) {
                            if (Math.random() < 0.08) { spawnIceberg(r, c); c += 5; }
                            break;
                        }
                    }
                }
            }
            
            cleanupFloatingBlocks();

            for(let c=2; c < COLS-2; c++) {
                let r = 0;
                while(r < ROWS && world[r][c] === TILES.AIR) r++;
                if (r >= ROWS) continue; 
                let ground = world[r][c]; let plantY = r - 1; 
                if (plantY >= 0) {
                     if ((ground === TILES.GRASS || ground === TILES.SNOW) && Math.random() < 0.12) { 
                        if (r+1 < ROWS && world[r+1][c] !== TILES.AIR && world[r+1][c] !== TILES.WATER) {
                             growTree(plantY, c); c += 2; 
                        }
                    } 
                    else if (world[plantY][c] === TILES.AIR && Math.random() < 0.3) {
                            let flowerId = 0;
                            if (ground === TILES.GRASS) flowerId = 20 + Math.floor(Math.random() * 5);
                            else if (ground === TILES.SAND) flowerId = 25 + Math.floor(Math.random() * 5);
                            else if (ground === TILES.SNOW) flowerId = 30 + Math.floor(Math.random() * 5);
                            if (flowerId > 0) world[plantY][c] = flowerId;
                    }
                }
            }
            initAtmosphere();
            player.x = (COLS * TILE_SIZE) / 2; player.y = 0; player.vx = 0; player.vy = 0;
            updateHUD();
        }
        
        function spawnIceberg(surfaceR, c) {
            let width = 2 + Math.floor(Math.random() * 3);
            for(let y = -2; y <= 1; y++) {
                for(let x = -width; x <= width; x++) {
                    let r = surfaceR + y; let col = c + x;
                    if (r >= 0 && r < ROWS && col >= 0 && col < COLS) {
                        if (Math.abs(x) + Math.abs(y) <= width + Math.random()) {
                            if (world[r][col] === TILES.AIR || world[r][col] === TILES.WATER) world[r][col] = TILES.ICE;
                        }
                    }
                }
            }
        }

        function growTree(baseR, baseC) {
            let height = 4 + Math.floor(Math.random() * 3);
            for(let h=0; h < height; h++) { if(baseR-h >= 0) world[baseR-h][baseC] = TILES.WOOD; }
            let crownY = baseR - height + 1;
            for(let y = crownY - 2; y <= crownY + 1; y++) {
                for(let x = baseC - 2; x <= baseC + 2; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        if (Math.abs(x - baseC) + Math.abs(y - crownY) <= 3) {
                             if(world[y][x] === TILES.AIR) world[y][x] = TILES.LEAVES;
                        }
                    }
                }
            }
        }

        function carveLake(cx, cy) {
            let r = 3 + Math.floor(Math.random() * 5); 
            for(let y = cy - r; y <= cy + r; y++) {
                for(let x = cx - r; x <= cx + r; x++) {
                    if (y >= 0 && y < ROWS && x >= 0 && x < COLS) {
                        let dist = Math.sqrt((x-cx)**2 + ((y-cy)*1.5)**2);
                        if (dist < r) {
                            if (y > cy) world[y][x] = TILES.WATER; else world[y][x] = TILES.AIR;
                            if (dist > r - 1.5 && world[y][x] !== TILES.AIR && world[y][x] !== TILES.WATER) world[y][x] = TILES.MUD;
                        }
                    }
                }
            }
        }

        function cleanupFloatingBlocks() {
            for(let i=0; i<2; i++) {
                for (let c = 0; c < COLS; c++) {
                    for (let r = ROWS - 2; r >= 0; r--) {
                        let tile = world[r][c];
                        let isTerrain = (tile === TILES.DIRT || tile === TILES.GRASS || tile === TILES.STONE || tile === TILES.MUD || tile === TILES.SAND || tile === TILES.SNOW);
                        if (isTerrain && world[r+1][c] === TILES.AIR) world[r][c] = TILES.AIR;
                    }
                }
            }
        }

        function updateCellularAutomata() {
            let startC = tickCount % 2 === 0 ? 0 : COLS - 1; let endC = tickCount % 2 === 0 ? COLS : -1; let step = tickCount % 2 === 0 ? 1 : -1;
            for (let r = ROWS - 2; r >= 0; r--) {
                for (let c = startC; c !== endC; c += step) {
                    let tile = world[r][c];
                    if (tile === TILES.MUD) {
                        let touchesWater = false;
                        if (r>0 && world[r-1][c] === TILES.WATER) touchesWater = true; else if (r<ROWS-1 && world[r+1][c] === TILES.WATER) touchesWater = true; else if (c>0 && world[r][c-1] === TILES.WATER) touchesWater = true; else if (c<COLS-1 && world[r][c+1] === TILES.WATER) touchesWater = true;
                        if (!touchesWater && Math.random() < 0.007) world[r][c] = TILES.DIRT;
                    }
                    if (isPermeable(tile)) { 
                        let below = world[r+1][c]; if (below === TILES.AIR || below === TILES.WATER) { world[r][c] = TILES.AIR; removeFromTorchList(r, c); } continue;
                    }
                    if (tile === TILES.SAND) {
                        if (world[r+1][c] === TILES.AIR || world[r+1][c] === TILES.WATER) { world[r][c] = world[r+1][c]; world[r+1][c] = TILES.SAND; } 
                        else if (world[r+1][c-1] === TILES.AIR && world[r][c-1] === TILES.AIR) { world[r][c] = TILES.AIR; world[r+1][c-1] = TILES.SAND; } 
                        else if (world[r+1][c+1] === TILES.AIR && world[r][c+1] === TILES.AIR) { world[r][c] = TILES.AIR; world[r+1][c+1] = TILES.SAND; }
                    }
                    if (tile === TILES.WATER) {
                        if (r + 1 < ROWS) { let below = world[r+1][c]; if ((below === TILES.DIRT || below === TILES.GRASS) && Math.random() < 0.005) world[r+1][c] = TILES.MUD; }
                        let down = world[r+1][c]; 
                        if (down === TILES.AIR || isPermeable(down)) { world[r][c] = TILES.AIR; world[r+1][c] = TILES.WATER; continue; }
                        let left = (c > 0) ? world[r][c-1] : -1; let right = (c < COLS-1) ? world[r][c+1] : -1;
                        let canLeft = (left === TILES.AIR || isPermeable(left)); let canRight = (right === TILES.AIR || isPermeable(right));
                        if (canLeft && canRight) { (Math.random() > 0.5) ? tryMoveWater(r, c, r, c+1) : tryMoveWater(r, c, r, c-1); } else if (canLeft) { tryMoveWater(r, c, r, c-1); } else if (canRight) { tryMoveWater(r, c, r, c+1); }
                    }
                }
            }
        }
        
        function removeFromTorchList(r, c) {
            torchList = torchList.filter(t => t.r !== r || t.c !== c);
        }

        function tryMoveWater(r, c, targetR, targetC) {
            let target = world[targetR][targetC];
            if (target === TILES.AIR || isPermeable(target)) { world[r][c] = TILES.AIR; world[targetR][targetC] = TILES.WATER; }
        }

        function getTileAt(x, y) {
            let c = Math.floor(x / TILE_SIZE); let r = Math.floor(y / TILE_SIZE);
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) return TILES.AIR;
            return world[r][c];
        }

        function updatePlayer() {
            let centerX = Math.floor((player.x + player.width/2) / TILE_SIZE);
            let centerY = Math.floor((player.y + player.height/2) / TILE_SIZE);
            if (centerY >= 0 && centerY < ROWS && centerX >= 0 && centerX < COLS) {
                player.inWater = (world[centerY][centerX] === TILES.WATER);
            } else { player.inWater = false; }

            let atSurface = player.inWater && (getTileAt(player.x, player.y) === TILES.AIR);
            let moveSpeed = 5; let dx = 0;
            if (keys['ArrowRight'] || keys['KeyD']) dx = moveSpeed; else if (keys['ArrowLeft'] || keys['KeyA']) dx = -moveSpeed;
            player.vx = dx;

            let jumping = (keys['Space'] || keys['ArrowUp'] || keys['KeyW']);
            if (jumping) {
                if (atSurface) { player.vy = -10; } 
                else if (player.inWater) { player.vy -= SWIM_FORCE; if (player.vy < -6) player.vy = -6; } 
                else if (player.grounded) { player.vy = -12; player.grounded = false; }
            }

            if (player.inWater) { if (!jumping) player.vy += BUOYANCY; player.vy += WATER_GRAVITY; player.vy *= WATER_DRAG; player.vx *= WATER_DRAG; } 
            else { player.vy += GRAVITY; }
            
            if (player.vx > 0) player.facingRight = true; if (player.vx < 0) player.facingRight = false;

            let nextX = player.x + player.vx;
            if (nextX < 0) nextX = 0; if (nextX > (COLS * TILE_SIZE) - player.width) nextX = (COLS * TILE_SIZE) - player.width;
            
            if (!checkCollision(nextX, player.y)) { player.x = nextX; } 
            else if ((player.grounded || player.inWater) && !checkCollision(nextX, player.y - TILE_SIZE)) { player.y -= TILE_SIZE; player.x = nextX; }

            player.grounded = false;
            let nextY = player.y + player.vy;
            if (nextY > ROWS * TILE_SIZE) { player.y = 0; player.vy = 0; nextY = 0; }

            if (player.vy > 0) { 
                if (checkCollision(player.x, nextY)) { player.vy = 0; player.grounded = true; player.y = Math.floor((nextY + player.height) / TILE_SIZE) * TILE_SIZE - player.height; } 
                else { player.y = nextY; }
            } else if (player.vy < 0) { 
                 if (checkCollision(player.x, nextY, true)) { player.vy = 0; } else { player.y = nextY; }
            }

            camera.x += (player.x - canvas.width / 2 - camera.x) * 0.1;
            camera.y += (player.y - canvas.height / 2 - camera.y) * 0.1;
        }

        function checkCollision(x, y, headCheck=false) {
            let startX = Math.floor(x / TILE_SIZE); let endX = Math.floor((x + player.width - 0.1) / TILE_SIZE);
            let startY = Math.floor(y / TILE_SIZE); let endY = Math.floor((y + player.height - 0.1) / TILE_SIZE);
            if (headCheck) endY = startY;
            for (let r = startY; r <= endY; r++) {
                for (let c = startX; c <= endX; c++) {
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) { if (isSolid(world[r][c])) return true; }
                }
            }
            return false;
        }

        // --- RENDER ---
        function getLightColor(r, c, tileType) {
            if (tileType === TILES.TORCH || tileType === TILES.CAMPFIRE) return `hsl(45, 100%, 60%)`; 
            
            let startShadow = ROWS * 0.75;
            let depthFactor = 1.0;
            if (r > startShadow) {
                let depth = r - startShadow; let maxDepth = ROWS - startShadow;
                depthFactor = 1.0 - ((depth / maxDepth) * 0.5); 
            }
            let sunBrightness = depthFactor * globalLightLevel;

            let torchBrightness = 0;
            if (globalLightLevel < 0.9) { 
                for(let t of torchList) {
                    let d = Math.sqrt((t.r - r)**2 + (t.c - c)**2);
                    if (d < 8) { 
                        let b = 1.0 - (d / 8);
                        if (b > torchBrightness) torchBrightness = b;
                    }
                }
            }
            
            let finalBrightness = Math.max(sunBrightness, torchBrightness);
            
            if (tileType === TILES.WATER) return `rgba(41, 182, 246, ${0.6 * finalBrightness})`; 
            if (tileType === TILES.ICE) return `rgba(165, 216, 243, ${0.9 * finalBrightness})`;

            let base = BASE_COLORS[tileType];
            if (!base) return 'magenta';

            let lightness = base[2] * finalBrightness;
            return `hsl(${base[0]}, ${base[1]}%, ${lightness}%)`;
        }

        function drawTile(r, c, tileType) {
            const x = c * TILE_SIZE; const y = r * TILE_SIZE;
            if (tileType >= 20 && tileType <= 34) { drawPlant(x, y, tileType); return; }
            if (tileType === TILES.TORCH) { drawTorch(x, y); return; }
            if (tileType === TILES.CAMPFIRE) { drawCampfire(x, y); return; }
            if (tileType === TILES.STICK) { drawStick(x, y); return; }

            let startShadow = ROWS * 0.75; let shade = 0;
            if (r > startShadow) { let depth = r - startShadow; let maxDepth = ROWS - startShadow; shade = (depth / maxDepth) * 0.85; }

            function fill(color) {
                ctx.fillStyle = color; ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                if (shade > 0) { ctx.fillStyle = `rgba(0,0,0,${shade})`; ctx.fillRect(x,y,TILE_SIZE,TILE_SIZE); }
            }

            if (tileType === TILES.DIRT) { fill(getLightColor(r, c, 1)); ctx.fillStyle = "rgba(0,0,0,0.2)"; let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4); }
            else if (tileType === TILES.GRASS) { fill(getLightColor(r, c, 1)); ctx.fillStyle = getLightColor(r, c, 2); ctx.fillRect(x, y, TILE_SIZE, 10); ctx.fillRect(x+2, y, 4, 12); ctx.fillRect(x+10, y, 4, 14); ctx.fillRect(x+20, y, 4, 11); }
            else if (tileType === TILES.STONE) { fill(getLightColor(r, c, 3)); ctx.fillStyle = "rgba(0,0,0,0.3)"; if((c+r)%2===0) ctx.fillRect(x+16, y, 2, 16); else ctx.fillRect(x+16, y+16, 2, 16); ctx.fillRect(x, y+16, TILE_SIZE, 2); }
            else if (tileType === TILES.WOOD) { fill(getLightColor(r, c, 7)); ctx.fillStyle = "rgba(40, 20, 0, 0.4)"; ctx.fillRect(x+6, y, 4, TILE_SIZE); ctx.fillRect(x+18, y, 2, TILE_SIZE); ctx.fillRect(x+26, y, 4, TILE_SIZE); }
            else if (tileType === TILES.PLANKS) { fill(getLightColor(r, c, 12)); ctx.fillStyle = "rgba(0,0,0,0.3)"; for(let i=1; i<4; i++) ctx.fillRect(x, y + (i*8), TILE_SIZE, 2); ctx.fillStyle = "rgba(0,0,0,0.6)"; ctx.fillRect(x+2, y+3, 2, 2); ctx.fillRect(x+28, y+3, 2, 2); ctx.fillRect(x+2, y+11, 2, 2); ctx.fillRect(x+28, y+11, 2, 2); }
            else if (tileType === TILES.LEAVES) { fill(getLightColor(r, c, 8)); ctx.fillStyle = `hsl(120, 40%, ${40 * globalLightLevel}%)`; ctx.fillRect(x+4, y+4, 8, 6); ctx.fillRect(x+18, y+18, 6, 8); }
            else if (tileType === TILES.SAND) { fill(getLightColor(r, c, 4)); ctx.fillStyle = "rgba(200, 150, 0, 0.2)"; let n = (c * r * 13) % 10; if(n<3) ctx.fillRect(x+4, y+4, 4, 4); if(n>6) ctx.fillRect(x+20, y+20, 4, 4); }
            else if (tileType === TILES.SNOW) { fill(getLightColor(r, c, 1)); ctx.fillStyle = "rgba(0,0,0,0.2)"; let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4); ctx.fillStyle = `hsl(0, 0%, ${100 * globalLightLevel}%)`; ctx.fillRect(x, y, TILE_SIZE, 10); ctx.fillRect(x+2, y, 4, 12); ctx.fillRect(x+10, y, 4, 14); ctx.fillRect(x+20, y, 4, 11); }
            else if (tileType === TILES.ICE) { fill(getLightColor(r, c, 14)); ctx.fillStyle = "rgba(255,255,255,0.4)"; ctx.beginPath(); ctx.moveTo(x, y+TILE_SIZE); ctx.lineTo(x+TILE_SIZE, y); ctx.stroke(); ctx.fillRect(x+5, y+5, 4, 4); }
            else if (tileType === TILES.WATER) { ctx.fillStyle = getLightColor(r, c, 5); ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE); ctx.fillStyle = "rgba(255, 255, 255, 0.3)"; ctx.fillRect(x+4, y+4, 8, 2); ctx.fillRect(x+16, y+10, 10, 2); }
            else if (tileType === TILES.MUD) { fill(getLightColor(r, c, 6)); ctx.fillStyle = "rgba(0,0,0,0.35)"; let s = (c*r)%5; if(s==0) ctx.fillRect(x+4,y+4,4,4); if(s==1) ctx.fillRect(x+20,y+10,4,4); }
            else if (tileType === TILES.COAL_ORE) { drawTile(r, c, TILES.STONE); ctx.fillStyle = "#111"; ctx.beginPath(); ctx.arc(x+16, y+16, 6, 0, 2*Math.PI); ctx.fill(); }
            else if (tileType === TILES.GOLD_ORE) { drawTile(r, c, TILES.STONE); ctx.fillStyle = `hsl(50, 100%, ${50 * globalLightLevel}%)`; ctx.fillRect(x+10, y+10, 12, 12); ctx.fillStyle="#fff"; ctx.fillRect(x+12,y+12,4,4); }
            else if (tileType === TILES.DIAMOND_ORE) { drawTile(r, c, TILES.STONE); ctx.fillStyle = `hsl(180, 100%, ${50 * globalLightLevel}%)`; ctx.beginPath(); ctx.moveTo(x+16, y+8); ctx.lineTo(x+24, y+16); ctx.lineTo(x+16, y+24); ctx.lineTo(x+8, y+16); ctx.fill(); }
        }

        function drawTorch(x, y) {
            ctx.fillStyle = "#5d4037"; ctx.fillRect(x + 14, y + 10, 4, 22);
            let flicker = Math.random() * 0.2;
            ctx.fillStyle = `rgba(255, 235, 59, ${0.8 + flicker})`; ctx.fillRect(x + 12, y + 4, 8, 8);
            ctx.fillStyle = `rgba(255, 152, 0, ${0.6 + flicker})`; ctx.fillRect(x + 10, y + 6, 12, 6);
            ctx.fillStyle = `rgba(244, 67, 54, ${0.5 + flicker})`; ctx.fillRect(x + 14, y + 2, 4, 4);
        }

        function drawCampfire(x, y) {
            // Logs
            ctx.fillStyle = "#5d4037";
            ctx.fillRect(x+2, y+24, 28, 6); // horizontal
            ctx.fillRect(x+6, y+20, 6, 4); ctx.fillRect(x+20, y+20, 6, 4); // ends
            
            let flicker = Math.random() * 0.2;
            // Fire
            ctx.fillStyle = `rgba(255, 87, 34, ${0.8+flicker})`; 
            ctx.beginPath(); ctx.moveTo(x+4, y+24); ctx.lineTo(x+16, y+2); ctx.lineTo(x+28, y+24); ctx.fill();
            ctx.fillStyle = `rgba(255, 235, 59, ${0.6+flicker})`;
            ctx.beginPath(); ctx.moveTo(x+10, y+24); ctx.lineTo(x+16, y+10); ctx.lineTo(x+22, y+24); ctx.fill();
        }

        function drawStick(x, y) {
            ctx.save();
            ctx.translate(x+16, y+16);
            ctx.rotate(45 * Math.PI / 180);
            ctx.fillStyle = "#795548";
            ctx.fillRect(-2, -10, 4, 20);
            ctx.restore();
        }

        function drawPlant(x, y, id) {
            ctx.filter = `brightness(${globalLightLevel})`;
            let variant = id % 5; const stemGreen = "#2e7d32"; const darkStem = "#1b5e20"; const cactusGreen = "#558b2f"; const deadBrown = "#795548"; const iceBlue = "#81d4fa";
            switch(id) {
                case 20: ctx.fillStyle = stemGreen; ctx.fillRect(x+14, y+16, 4, 16); ctx.fillStyle = "#e91e63"; ctx.fillRect(x+10, y+8, 12, 10); ctx.fillRect(x+10, y+6, 4, 2); ctx.fillRect(x+18, y+6, 4, 2); break;
                case 21: ctx.fillStyle = darkStem; ctx.fillRect(x+14, y+10, 4, 22); ctx.fillStyle = "#9c27b0"; ctx.fillRect(x+12, y+10, 8, 4); ctx.fillRect(x+12, y+16, 8, 4); ctx.fillRect(x+12, y+22, 8, 4); break;
                case 22: ctx.fillStyle = stemGreen; ctx.fillRect(x+14, y+14, 4, 18); ctx.fillStyle = "#ffeb3b"; ctx.fillRect(x+8, y+4, 16, 16); ctx.fillStyle = "#3e2723"; ctx.fillRect(x+12, y+8, 8, 8); break;
                case 23: ctx.fillStyle = stemGreen; ctx.fillRect(x+14, y+20, 4, 12); ctx.fillStyle = "#2196f3"; ctx.fillRect(x+8, y+12, 6, 6); ctx.fillRect(x+18, y+12, 6, 6); ctx.fillRect(x+13, y+8, 6, 6); break;
                case 24: ctx.fillStyle = stemGreen; ctx.fillRect(x+15, y+16, 2, 16); ctx.fillStyle = "#f44336"; ctx.fillRect(x+6, y+12, 20, 6); ctx.fillRect(x+10, y+18, 12, 2); ctx.fillStyle = "#111"; ctx.fillRect(x+14, y+14, 4, 4); break;
                case 25: ctx.fillStyle = cactusGreen; ctx.fillRect(x+10, y+6, 12, 26); ctx.fillStyle = "#33691e"; ctx.fillRect(x+12, y+8, 2, 22); break;
                case 26: ctx.fillStyle = cactusGreen; ctx.fillRect(x+12, y+8, 8, 24); ctx.fillRect(x+4, y+14, 8, 4); ctx.fillRect(x+4, y+10, 4, 4); ctx.fillRect(x+20, y+18, 8, 4); ctx.fillRect(x+24, y+14, 4, 4); break;
                case 27: ctx.fillStyle = cactusGreen; ctx.fillRect(x+6, y+16, 20, 16); ctx.fillStyle = "#e91e63"; ctx.fillRect(x+12, y+12, 8, 4); break;
                case 28: ctx.fillStyle = deadBrown; ctx.fillRect(x+14, y+24, 4, 8); ctx.fillRect(x+10, y+20, 4, 4); ctx.fillRect(x+18, y+22, 4, 4); break;
                case 29: ctx.fillStyle = deadBrown; ctx.fillRect(x+8, y+12, 16, 16); ctx.fillStyle = "#5d4037"; ctx.fillRect(x+12, y+16, 8, 8); ctx.fillRect(x+4, y+18, 4, 4); ctx.fillRect(x+24, y+14, 4, 4); break;
                case 30: ctx.fillStyle = iceBlue; ctx.beginPath(); ctx.moveTo(x+16, y+4); ctx.lineTo(x+24, y+24); ctx.lineTo(x+8, y+24); ctx.fill(); ctx.fillStyle = "white"; ctx.fillRect(x+14, y+8, 4, 16); break;
                case 31: ctx.fillStyle = darkStem; ctx.fillRect(x+14, y+24, 4, 8); ctx.fillStyle = "#2e7d32"; ctx.fillRect(x+6, y+16, 20, 10); ctx.fillStyle = "white"; ctx.fillRect(x+6, y+14, 20, 4); ctx.fillRect(x+10, y+18, 4, 4); break;
                case 32: ctx.fillStyle = "#4fc3f7"; ctx.fillRect(x+14, y+16, 4, 16); ctx.fillStyle = "#b3e5fc"; ctx.fillRect(x+10, y+8, 12, 10); ctx.fillStyle = "white"; ctx.fillRect(x+10, y+8, 4, 4); ctx.fillRect(x+18, y+8, 4, 4); break;
                case 33: ctx.fillStyle = iceBlue; ctx.fillRect(x+8, y+10, 2, 22); ctx.fillRect(x+16, y+6, 2, 26); ctx.fillRect(x+24, y+14, 2, 18); break;
                case 34: ctx.fillStyle = "#4fc3f7"; ctx.fillRect(x+14, y+20, 4, 12); ctx.fillStyle = "white"; ctx.fillRect(x+10, y+8, 12, 12); ctx.fillStyle = "#00e5ff"; ctx.fillRect(x+13, y+11, 6, 6); break;
            }
            ctx.filter = "none";
        }

        function drawPlayer() {
            ctx.fillStyle = '#e74c3c'; ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.fillStyle = '#f1c40f'; ctx.fillRect(player.x, player.y, player.width, 12); 
            ctx.fillStyle = '#000'; 
            let eyeX = player.facingRight ? player.x + 14 : player.x + 2;
            ctx.fillRect(eyeX, player.y + 4, 4, 4);
            if (player.inWater) { ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.fillRect(player.x - 4, player.y + 10, 4, 4); }
        }

        function drawAtmosphere(layer) {
            if (layer === 0) {
                clouds.forEach(c => {
                    ctx.fillStyle = `rgba(255, 255, 255, ${c.opacity * globalLightLevel})`;
                    ctx.beginPath(); ctx.roundRect(c.x, c.y, c.width, c.height, c.height/2); ctx.fill();
                    ctx.beginPath(); ctx.arc(c.x + c.width*0.2, c.y, c.height*0.6, 0, Math.PI*2); ctx.arc(c.x + c.width*0.8, c.y + c.height*0.2, c.height*0.5, 0, Math.PI*2); ctx.fill();
                });
            } else if (layer === 1) {
                 fog.forEach(f => {
                    let fogColor = (globalLightLevel < 0.7) ? `rgba(150, 150, 180, ${f.opacity})` : `rgba(220, 220, 235, ${f.opacity})`;
                    ctx.fillStyle = fogColor;
                    let grad = ctx.createLinearGradient(f.x, f.y, f.x, f.y + f.height);
                    grad.addColorStop(0, fogColor); grad.addColorStop(1, `rgba(255,255,255,0)`);
                    ctx.fillStyle = grad; ctx.fillRect(f.x, f.y, f.width, f.height);
                });
            }
        }

        function draw() {
            let grad = ctx.createLinearGradient(0, 0, 0, canvas.height);
            grad.addColorStop(0, `rgb(${currentSky[0]}, ${currentSky[1]}, ${currentSky[2]})`);
            grad.addColorStop(1, `rgb(${currentSky[0]*0.7}, ${currentSky[1]*0.7}, ${currentSky[2]*0.7})`);
            ctx.fillStyle = grad; ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.save();
            ctx.translate(Math.round(-camera.x), Math.round(-camera.y));

            drawAtmosphere(0);

            let startCol = Math.floor(camera.x / TILE_SIZE) - 2; let endCol = startCol + (canvas.width / TILE_SIZE) + 4;
            let startRow = Math.floor(camera.y / TILE_SIZE) - 2; let endRow = startRow + (canvas.height / TILE_SIZE) + 4;

            for (let r = startRow; r < endRow; r++) {
                for (let c = startCol; c < endCol; c++) {
                    if (r >= 0 && r < ROWS && c >= 0 && c < COLS) {
                        if (world[r][c] !== TILES.AIR) drawTile(r, c, world[r][c]);
                    }
                }
            }
            
            drawPlayer();
            drawAtmosphere(1);

            if (mouseTile.c >= 0) { ctx.strokeStyle = "rgba(255,255,255,0.8)"; ctx.lineWidth = 2; ctx.strokeRect(mouseTile.c*TILE_SIZE, mouseTile.r*TILE_SIZE, TILE_SIZE, TILE_SIZE); }

            // Draw Mining Crack
            if (isMining && miningProgress > 0 && currentMiningTarget.r >= 0) {
                let r = currentMiningTarget.r;
                let c = currentMiningTarget.c;
                if (world[r][c] !== TILES.AIR) {
                    let hardness = TILE_HARDNESS[world[r][c]] || 15;
                    let ratio = miningProgress / hardness;
                    let x = c * TILE_SIZE;
                    let y = r * TILE_SIZE;
                    ctx.save();
                    ctx.translate(x + TILE_SIZE/2, y + TILE_SIZE/2);

                    ctx.beginPath();
                    let stages = Math.floor(ratio * 3) + 1;
                    ctx.strokeStyle = "rgba(0,0,0,0.7)";
                    ctx.lineWidth = 2;

                    if(stages >= 1) { ctx.moveTo(0, 0); ctx.lineTo(-5, -8); ctx.moveTo(0, 0); ctx.lineTo(6, 4); }
                    if(stages >= 2) { ctx.moveTo(0, 0); ctx.lineTo(8, -5); ctx.moveTo(0, 0); ctx.lineTo(-4, 10); }
                    if(stages >= 3) { ctx.moveTo(0, 0); ctx.lineTo(-10, -2); ctx.moveTo(0, 0); ctx.lineTo(5, 9); }

                    ctx.stroke();
                    ctx.restore();
                }
            }

            ctx.restore();
            requestAnimationFrame(loop);
        }

        function loop() {
            tickCount++;
            updatePlayer();
            updateMining();
            updateAtmosphere();
            drawClock();
            if (tickCount % 2 === 0) updateCellularAutomata();
            draw();
        }

        function updateMining() {
            if (!isMining) return;
            const r = currentMiningTarget.r;
            const c = currentMiningTarget.c;

            // Validate target
            if (r < 0 || r >= ROWS || c < 0 || c >= COLS) { isMining = false; miningProgress = 0; return; }
            const tile = world[r][c];
            if (tile === TILES.AIR) { isMining = false; miningProgress = 0; return; }

            // Validate distance
            let tileX = c * TILE_SIZE + TILE_SIZE/2; let tileY = r * TILE_SIZE + TILE_SIZE/2;
            let playerX = player.x + player.width/2; let playerY = player.y + player.height/2;
            let dist = Math.sqrt((tileX-playerX)**2 + (tileY-playerY)**2);
            if (dist > 150) { isMining = false; miningProgress = 0; return; } // Range limit

            // Calculate Power
            let power = 1;
            if (player.activeTool && TOOLS[player.activeTool]) {
                power = TOOLS[player.activeTool].power;
            }

            miningProgress += power;

            let hardness = TILE_HARDNESS[tile] || 15; // Default hardness
            if (miningProgress >= hardness) {
                // Break block
                inventory[tile]++;
                if (tile === TILES.TORCH || tile === TILES.CAMPFIRE) removeFromTorchList(r, c);
                world[r][c] = TILES.AIR;

                // Durability
                if (player.activeTool) {
                    player.currentToolDurability--;
                    if (player.currentToolDurability <= 0) {
                        inventory[player.activeTool]--;
                        if (inventory[player.activeTool] > 0) {
                            player.currentToolDurability = TOOLS[player.activeTool].durability;
                        } else {
                            player.activeTool = null;
                            selectedBlock = TILES.DIRT; // revert to default? or nothing
                            // Actually, updateHUD will handle showing active item
                        }
                    }
                }

                updateHUD();
                miningProgress = 0;
                isMining = false; // Stop mining after break? Or continue? Usually continue if mouse held.
                // If mouse held, we need to know if we should continue.
                // Mouse event sets isMining=true. But if block is gone, next frame checks world[r][c] is AIR and stops.
                // So if user keeps holding, we need to find new target.
                // But mousemove updates mouseTile.
                // If we want continuous mining, we should re-evaluate target based on mouse position.
                // But `updateMining` uses `currentMiningTarget`.
                // We should update `currentMiningTarget` to `mouseTile` if mouse is still down?
                // Let's keep it simple: Break one block, stop. User clicks again?
                // No, prompt says "If the mouse is held down...".
                // So if broken, we need to re-target.
                // But `mouseTile` is updated in `mousemove`.
                // So if I set isMining=false, it stops.
                // I should probably NOT set isMining=false if mouse is still down.
                // But `currentMiningTarget` points to Air now.
                // Next frame: tile === TILES.AIR -> isMining = false.
                // So mining stops. User has to click again.
                // To support continuous mining, we need to check mouse state.
                // We can't check mouse button state in loop easily without tracking it.
                // Let's assume we track mouseDown state.
                // I'll add `isMouseDown` variable in next step.
            }
        }

        // --- CONTROLS & UI ---
        function updateHUD() {
            const toolDiv = document.getElementById('tool-display');
            let toolName = mode === 'MINE' ? "⛏️ MINING" : "🧱 BUILDING";
            if (mode === 'BUILD') toolName += ": " + (TILE_NAMES[selectedBlock] || "Unknown");
            toolDiv.innerText = toolName; toolDiv.style.color = mode === 'MINE' ? "#ff7675" : "#55efc4";
            const invBar = document.getElementById('inventory-bar'); invBar.innerHTML = '';
            const showList = [TILES.DIRT, TILES.GRASS, TILES.STONE, TILES.SAND, TILES.MUD, TILES.WOOD, TILES.PLANKS, TILES.STICK, TILES.LEAVES, TILES.TORCH, TILES.CAMPFIRE, TILES.WATER, TILES.SNOW, TILES.ICE, TILES.COAL_ORE, TILES.GOLD_ORE, TILES.DIAMOND_ORE];
            // Add tools to showList
            [TILES.WOOD_PICK, TILES.STONE_PICK, TILES.IRON_PICK, TILES.GOLD_PICK, TILES.DIAMOND_PICK].forEach(t => { if(inventory[t] > 0) showList.push(t); });
            for(let i=20; i<=34; i++) { if(inventory[i]>0) showList.push(i); }
            showList.forEach(id => {
                const slot = document.createElement('div');
                slot.className = 'inv-slot ' + 'icon-' + id + (selectedBlock === id ? ' selected' : '');
                slot.innerHTML = `<span>${inventory[id]}</span>`; slot.title = TILE_NAMES[id] || ("ID: " + id);
                slot.onclick = () => {
                    selectedBlock = id;
                    if (TOOLS[id]) {
                        player.activeTool = id;
                        mode = 'MINE';
                    } else {
                        // If switching to non-tool, maybe clear activeTool?
                        // "Update Player Object: Add player.activeTool (stores the ID of the equipped item)."
                        // Usually if holding a block, we use hand? Or activeTool persists?
                        // Let's assume holding a block means "equipping" it, so activeTool should be null (Hand).
                        player.activeTool = null;
                        mode = 'BUILD';
                    }
                    updateHUD();
                };
                invBar.appendChild(slot);
            });
        }

        const keys = {};
        let isMouseDown = false;

        window.addEventListener('keydown', e => {
            keys[e.code] = true;
            if (e.code === 'KeyE') { mode = mode === 'MINE' ? 'BUILD' : 'MINE'; updateHUD(); }
            if (e.code === 'KeyC') { openCraftingMenu(); }
            // Escape Key to close menus
            if (e.code === 'Escape') {
                document.getElementById('crafting-overlay').style.display = 'none';
                document.getElementById('modal-overlay').style.display = 'none';
                document.getElementById('lan-overlay').style.display = 'none';
            }
            if (e.key >= '1' && e.key <= '9') { const map = [0, TILES.DIRT, TILES.GRASS, TILES.STONE, TILES.SAND, TILES.MUD, TILES.WOOD, TILES.PLANKS, TILES.TORCH, TILES.WATER, TILES.SNOW]; if (map[e.key]) { selectedBlock = map[e.key]; mode = 'BUILD'; updateHUD(); } }
        });
        window.addEventListener('keyup', e => { keys[e.code] = false; });

        canvas.addEventListener('mousemove', e => {
            const r = canvas.getBoundingClientRect();
            mouseTile.c = Math.floor((e.clientX - r.left + camera.x) / TILE_SIZE);
            mouseTile.r = Math.floor((e.clientY - r.top + camera.y) / TILE_SIZE);

            if (isMouseDown && mode === 'MINE') {
                if (mouseTile.c !== currentMiningTarget.c || mouseTile.r !== currentMiningTarget.r) {
                    currentMiningTarget = { r: mouseTile.r, c: mouseTile.c };
                    miningProgress = 0;
                    isMining = true;
                }
            }
        });

        canvas.addEventListener('mousedown', e => {
            isMouseDown = true;
            const c = mouseTile.c, r = mouseTile.r;
            if (r>=0 && r<ROWS && c>=0 && c<COLS) {
                 if (mode === 'MINE') {
                    currentMiningTarget = { r, c };
                    miningProgress = 0;
                    isMining = true;
                 } else {
                     let tileX = c * TILE_SIZE; let tileY = r * TILE_SIZE;
                     let intersect = ( player.x < tileX + TILE_SIZE && player.x + player.width > tileX && player.y < tileY + TILE_SIZE && player.y + player.height > tileY );
                     if (!intersect && world[r][c] === TILES.AIR && inventory[selectedBlock] > 0) { 
                         world[r][c] = selectedBlock; 
                         if(selectedBlock === TILES.TORCH || selectedBlock === TILES.CAMPFIRE) torchList.push({r, c});
                         inventory[selectedBlock]--; updateHUD(); 
                     }
                 }
            }
        });

        window.addEventListener('mouseup', () => {
            isMouseDown = false;
            isMining = false;
            miningProgress = 0;
        });
        window.addEventListener('resize', () => { canvas.width = window.innerWidth; canvas.height = window.innerHeight; });

        function openModal() { document.getElementById('modal-overlay').style.display = 'flex'; }
        function closeModal() { document.getElementById('modal-overlay').style.display = 'none'; }
        function confirmNewWorld(w, h) { initWorld(w, h); inventory = {}; Object.values(TILES).forEach(v => { if(v!==0) inventory[v]=0; }); for(let i=20; i<=34; i++) inventory[i] = 0; closeModal(); }
        
        function saveGame() { 
            localStorage.setItem('vivaria_v18', JSON.stringify({ world, player, inventory, COLS, ROWS, worldTime, torchList })); 
            alert("Saved!"); 
        }
        function loadGame() { 
            const data = JSON.parse(localStorage.getItem('vivaria_v18')); 
            if (data) { 
                COLS = data.COLS; ROWS = data.ROWS; world = data.world; player = data.player; inventory = data.inventory; 
                worldTime = data.worldTime || 6000; 
                torchList = data.torchList || []; 
                initAtmosphere(); updateHUD(); alert("Loaded!"); 
            } 
        }
        function exportSave() { const blob = new Blob([JSON.stringify({ world, player, inventory, COLS, ROWS, worldTime, torchList })], {type: "application/json"}); const url = URL.createObjectURL(blob); const a = document.createElement('a'); a.href = url; a.download = "vivaria_save.json"; a.click(); }
        function importSave(input) { const file = input.files[0]; if (!file) return; const reader = new FileReader(); reader.onload = function(e) { try { const data = JSON.parse(e.target.result); COLS = data.COLS; ROWS = data.ROWS; world = data.world; player = data.player; inventory = data.inventory; worldTime = data.worldTime || 6000; torchList = data.torchList || []; initAtmosphere(); updateHUD(); alert("Imported!"); } catch(err) { alert("Invalid File"); } }; reader.readAsText(file); }

        canvas.width = window.innerWidth; canvas.height = window.innerHeight;
        initWorld(COLS, ROWS);
        inventory[TILES.WOOD] = 5;
        inventory[TILES.COAL_ORE] = 2;
        updateHUD();
        loop();
    </script>
</body>
</html>
